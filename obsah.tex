%=========================================================================
% (c) Radim Loskot, 2014

\chapter{Úvod}
\label{Chapter.Introducion}

Funkci a význam webových prohlížečů netřeba dlouze představovat. Prohlížeče nám denně umožňují rychle a pohodlně procházet webový obsah a tzv. HTML dokumenty. HTML dokumenty nemusí být výhradně umístěny pouze na webu a na vzdálených úložištích, ale mohou přicházet i v rámci elektronické pošty nebo být součástí aplikační nápovědy, aj. Pro zobrazování HTML dokumentů používáme HTML zobrazovacích strojů. Jedním takovým strojem je CSSBox.

CSSBox je projekt experimentálního (X)HTML/CSS zobrazovacího stroje napsaného v~čistém jazyce Java. Projekt se snaží vyplnit prostor v implementacích zobrazovacích strojů v Javě, jejichž vývoj většinou ustal. Hlavním cílem projektu je poskytnout úplné a dále zpracovatelné informace o rozložení dokumentu. Vyjma analyzování dokumentu umožnuje již v samotném základu vizualizovat dokument jako prostý obrázek. V rámci samostatného podprojektu SwingBox dále díky komponentě \texttt{BrowserPane} přidává pokročilé grafické rozhraní pro zobrazování dokumentu, které dokáže reagovat i na události od uživatele.

V současné době CSSBox implementuje (X)HTML/CSS 2.1 analyzátor a výše zmíněné zobrazovací komponenty. Cílem této práce je projekt CSSBox rozšířit o možnost skriptování v dokumentu a implementovat vybranou základní množinu skriptovacího jazyka JavaScript. Jakým způsobem bude integrace docíleno, je popsáno v následujícím dokumentu.

V úvodu tohoto dokumentu -- v kapitole \ref{Chapter.DependenciesAnalysis.ScriptsInHTML} se pojednává o způsobech, jakým mohou být vloženy skripty do HTML dokumentů, a je demonstrován referenční přístup pro přidání skriptování do dokumentů podle doporučené specifikace HTML 5. Základní architektura použitých závislostí -- projektu CSSBox a SwingBox je uvedena v kapitolách \ref{Chapter.DependenciesAnalysis.CSSBox} a \ref{Chapter.DependenciesAnalysis.SwingBox}.

Kapitola \ref{Chapter.JavaScriptInJavaAnalysis} je zaměřena na analýzu dostupných skriptovacích strojů v současnosti a rozbor jejich API. V rámci této kapitoly je představeno i standardní Java API, které lze pro skriptování v Javě využít.

V poslední kapitole návrhu -- kapitole \ref{Chapter.Design} je nastíněn základní abstraktní návrh celé integrace nového rozšíření do projektu SwingBox. Postupně jsou ukázány jednotlivé náležitosti, které bude zapotřebí vykonat, aby bylo možné integraci provést. V závěru \linebreak[4]dokumentu -- kapitole \ref{Chapter.Design.SwingBoxIntegration} je demonstrována „registrace“ samotného rozšíření do projektu SwingBox.


\chapter{Analýza použitých technik}
\label{Chapter.DependenciesAnalysis}

V rámci této práce se budeme zabývat integrací podpory skriptování v JavaScriptu ve stroji CSSBox. Abychom mohli provést návrh knihovny implementující rozšíření stroje CSSBox, je zapotřebí upřesnit, jak jsou skripty v HTML dokumentech reprezentovány, jak jsou vykonávány a do jakého rozhraní je budeme integrovat.

Problematikou skriptování v HTML dokumentech se zabývá kapitola \ref{Chapter.DependenciesAnalysis.ScriptsInHTML}. Na projekt CSSBox, jeho architekturu je zaměřena kapitola \ref{Chapter.DependenciesAnalysis.CSSBox}. Komponenta, která bude použita pro zobrazování HTML dokumentů a která bude implementovat rozšíření skriptování v těchto dokumentech, je popsána v kapitole \ref{Chapter.DependenciesAnalysis.SwingBox}. 

\section{Klientské skripty v HTML dokumentu}
\label{Chapter.DependenciesAnalysis.ScriptsInHTML}

Klientský skript je program, který může doprovázet HTML dokument nebo být do něj přímo vložen. Skript je vykonáván na straně klienta buď ihned po jeho načtení, po načtení celého dokumentu nebo při výskytu některé události. Skripty mohou:

\begin{itemize}
  \item sloužit k modifikaci obsahu dokumentu;
  \item být spuštěny událostmi ovládacích prvků a jinými událostmi prohlížeče;
  \item být využity pro validaci a odesílání obsahu formuláře na server.
\end{itemize}

\noindent Pro vložení nového skriptu do HTML dokumentu a jeho příp. vykonání máme několik způsobů, např.:

\begin{enumerate}
  \item Uvést skript v dokumentu ve speciální značce \texttt{<script>};
  \item Vložit skript do atributu určeného pro událostní obslužnou rutinu, který se bude vykonávat vždy po výskytu dané události, např. do atributu \texttt{onclick}.
  \item Vložit skript do dokumentu dynamicky tím, že vložíme do dokumentu pomocí skriptu nový element \texttt{<script>} a definujeme jeho vykonávací kód.
\end{enumerate}

Skripty ve značkách \texttt{<script>} jsou spouštěny samostatně, vždy pouze jednou a nikoliv opakovaně tak jako skripty vytvářené v atributu pro událostní obslužné rutiny. Během zpracovávání dokumentu jsou jednotlivé skripty v těch značkách vykonány. Jak a v jakém pořadí spouštění skriptů probíhá, popíšeme dále v této kapitole.

V rámci samotné značky \texttt{<script>} můžeme podle doporučené specifikace HTML 5 rozlišit celkem 6 atributů. Všechny atributy řídí vykonávání skriptu v určitém momentu jeho zpracovávání a jejich dynamická změna nemá žádný efekt na průběh skriptu. Specifikace uvádí následující atributy:

\begin{enumerate}
  \item \textbf{\texttt{src}} -- URL\footnote{URL (Uniform Resource Locator) -- řetězec sloužící k jednoznačné identifikaci zdroje} souboru s externím skriptem;
  \item \textbf{\texttt{type}} -- MIME\footnote{MIME (Multipurpose Internet Mail Extensions) -- internetový standard definující různé typy internetového média} typ skriptu;
  \item \textbf{\texttt{charset}} -- typ kódování souboru s externím skriptem;
  \item \textbf{\texttt{async}} -- udává, zda bude skript spuštěn asynchronně;
  \item \textbf{\texttt{defer}} -- specifikuje odložení spuštění skriptu až do dokončení načtení dokumentu;
  \item \textbf{\texttt{crossorigin}} -- pokud je atribut přítomem, pak bude na server zaslán CORS\footnote{ CORS (Cross-origin resource sharing) -- Mechanismus umožňující stahování zdrojů z více povolených domén než pouze z domény, ze které pochází dotazovaný zdroj.} požadavek. 
\end{enumerate}

Kromě samotných atributů elementu skriptu specifikace HTML 5 doporučuje asociovat s elementem \texttt{<script>} i speciální příznaky. Příznaky jsou nastavovány na základě toho, kde byl element skriptu zpracován a na základě výše zmíněných atributů. Uvedenými příznaky ve specifikaci jsou:

\begin{enumerate}
  \item \textbf{\texttt{already-started}} -- značí, zda byl skript již vykonán. Při klonování elementu \texttt{<script>} se musí příznak sdílet;
  \item \textbf{\texttt{parser-inserted}} -- příznak je nastaven pro všechny skripty vložené do dokumentu HTML nebo XML parserem, např. při vložení pomocí \texttt{document.write()}. Skripty vložené při vytváření dokumentu nemají tento příznak nastaven;
  \item \textbf{\texttt{force-async}} -- během počátečního zpracování dokumentu je příznak nastaven. Skripty nemají tento příznak nastaven, pokud jsou vytvořeny a vloženy do dokumentu dodatečně, nebo pokud mají specifikovaný atribut \texttt{async};
  \item \textbf{\texttt{ready-to-be-parser-executed}} -- příznak používaný pouze pro skripty, které byly vloženy dodatečně některým z parserů dokumentu. Příznak je nastaven, pokud dojde k úspěšnému načtení skriptu z externího zdroje;
  \item \textbf{\texttt{script-type a script-charset}} -- jsou příznaky, které pouze reflektují atributy elementu \texttt{<script>}. Pokud nejsou atributy skriptu nastaveny, nebo jsou nastaveny špatně, pak obsahují tyto příznaky opravené nebo výchozí hodnoty těchto atributů.
\end{enumerate}

Nastavování části výše zmíněných příznaků by měl obsluhovat parser dokumentu během tvorby elementu \texttt{<script>}. Před spuštěním skriptu by se podle specifikace HTML 5 měla provést příprava skriptu. Příprava zahrnuje několik kroků, které nastaví příznaky např. \texttt{script-type} a \texttt{script-charset}, případně upraví příznaky nastavené parserem. 

Příprava elementu \texttt{<script>} pro jeho budoucí spuštění je provedena, pokud skript nemá nastaven příznak \texttt{parser-inserted} a pokud nastane:

\begin{enumerate}
  \item vložení elementu požadovaného skriptu do dokumentu,
  \item vložení nového uzlu nebo fragmentu dokumentu do již existujícího skriptu,
  \item nastavení atributu src, který nebyl předtím nastaven.
\end{enumerate}

Prvotní fáze přípravy skriptu, jíž výsledkem je nastavení příznaku \texttt{already-started}, tj., zda je skript spustitelný, je znázorněna v příloze \ref{Annex.ScriptPreprocessing}. Během přípravy dochází také k~zahájení načítání skriptů z externích zdrojů a umisťování jejich spuštění do front skriptů ke spuštění, aniž by docházelo k čekání, než jsou skripty kompletně načteny. 

Pokud spouštíme skript existující přímo v dokumentu, je jeho vykonávání zahájeno ihned a to i bez ohledu, zda předchozí skripty skončily své provádění. Všechny skripty, které mají uvedený externí zdroj, nejsou \texttt{parser-inserted} a byly již načteny, jsou spouštěny také okamžitě bez zbytečného čekání. Naopak problematika umísťování blokujících skriptů z důvodu čekání na zpracování stylů nebo \texttt{parser-inserted} skriptů do front skriptů ke spuštění je značně komplikovaná. Více o zpracovávání těchto skriptů si lze dočíst v samotné specifikaci HTML 5 \cite{Bibliography.HTML5.Scripting}.

\section{Renderovací stroj CSSBox}
\label{Chapter.DependenciesAnalysis.CSSBox}

CSSBox je projekt (X)HTML/CSS renderovacího stroje napsaného v čistém jazyce Java. Projekt klade velký důraz na poskytnutí informací o zpracovávané stránce.

Renderovací stroj CSSBox očekává na svém vstupu model dokumentu - DOM\footnote{DOM (Data Object Model) -- objektově orientovaná reprezentace XML nebo HTML dokumentu}. Dokument je v rámci stroje získáván pomocí parseru NekoHTML, ale může být získáván i jiným způsobem. Rozhraním pro všechny zdroje dokumentu je abstraktní třída \texttt{DOMSource}. Pro zpracování stylů dokumentu slouží třída \texttt{DOMAnalyzer}, která převede aktuální dokument na rozložení stránky. Výsledný model rozložení stránky se využívá pro zobrazení stránky, v knihovně je pro tento účel implementována komponenta \texttt{BrowserCanvas}.

\begin{figure}[H]
  \begin{center}
    \scalebox{0.65}{
      \includegraphics{fig/cssbox.pdf}
    }
    \caption{Hierarchie zobrazovacích komponent třídy \texttt{Box}}
    \label{Figure.BoxHierarchy}
  \end{center}
\end{figure}

Komponenta \texttt{BrowserCanvas} vytváří strom vykreslených objektů třídy Box. Strom je vytvářen ze vstupního dokumentu a výstupu analyzátoru stylů. Ke každému vykreslovanému elementu dokumentu, je vytvořen třídou \texttt{BrowserCanvas} jeho odpovídající \texttt{Box}. Každý prvek HTML stránky se pojí se specializovanou třídou \texttt{Box}, jak je znázorněno na obrázku \ref{Figure.BoxHierarchy}. Typ boxu nemusí být určen pouze typem elementu dokumentu, ale i jeho styly. Pokud blokový prvek má nastaveno zobrazení na řádku, tak bude ve stromu reprezentován třídou \texttt{InlineBox} a nikoliv třídou \texttt{BlockBox}. 

\clearpage

\section{Projekt SwingBox}
\label{Chapter.DependenciesAnalysis.SwingBox}

V rámci podprojektu SwingBox, který je součástí projektu CSSBox, byla vyvinuta komponenta \texttt{BrowserPane} \cite{Bibliography.SwingBox.Thesis}, která rozšiřuje funkčnost základního zobrazování dokumentu komponentou \texttt{BrowserCanvas}. Komponenta \texttt{BrowserPane} vychází ze třídy \texttt{JEditorPane}, ve které předefinovává výchozí zobrazování (X)HTML dokumentů. Pro zobrazování těchto dokumentů využívá třídu \texttt{SwingBoxEditorKit}, která zařizuje veškerou logiku zobrazování.

Komponenta \texttt{BrowserPane} umožňuje načítat dokumenty předáním jejich URL adresy, předáním dokumentu jako textový řetězec, nebo předání vstupního streamu s dokumentem. Na základě typu dokumentu, který má být zobrazen, komponenta dále volá pro čtení dokumentu odpovídající kit -- v našem případě \texttt{SwingBoxEditorKit}. Kit zařizuje s použitím třídy \texttt{ContentReader} načtení rozvržení stránky (viz kapitola \ref{Chapter.DependenciesAnalysis.CSSBox}) a jeho převod na reprezentaci dokumentu \texttt{SwingBoxDocument}, tak jak ho přijímá rozhraní komponenty \texttt{JEditorPane}. Třída \texttt{ContentReader} provádí převod rozvržení stránky na prvky dokumentu, tzn., převádí objekty třídy \texttt{Box} na objekty třídy \texttt{ElementSpec}. Veškeré načítání dokumentu ve formě DOM a jeho rozvržení třídou \texttt{DOMAnalyzer}, je prováděno ve třídě \texttt{CSSBoxAnalyzer}, na kterou je reference uvnitř třídy \texttt{ContentReader}.

\begin{figure}[H]
  \begin{center}
    \scalebox{0.70}{
      \includegraphics{fig/swingbox.pdf}
    }
    \caption{Diagram tříd komponenty \texttt{BrowserPane}}
    \label{Figure.SwingBoxDesign}
  \end{center}
\end{figure}

Prvky dokumentu \texttt{SwingBoxDocument}, které vytváří třída \texttt{ContentReader}, jsou vykreslovány na zobrazovací plochu \texttt{BrowserPane} ve formě pohledů \texttt{View}. Vykreslování řídí automaticky komponenta \texttt{JEditorPane}, která zná referenci na továrnu pohledů \linebreak\texttt{SwingBoxViewFactory}. Továrna pohledů je používaná komponentou \texttt{JEditorPane} vždy při potřebě vykreslit požadovaný dokument. Továrna se využívá pro vytváření pohledů pro každý prvek dokumentu \texttt{SwingBoxDocument}. Jelikož prvky dokumentu \texttt{ElementSpec} v~sobě zapouzdřují informaci o tom, jaký box obalují, je možno vytvořit pohledy, které přesně korespondují s množinou boxů uvedených v kapitole \ref{Chapter.DependenciesAnalysis.CSSBox}.

\chapter{Analýza podpory skriptování v~jazyce JavaScript v~Javě}
\label{Chapter.JavaScriptInJavaAnalysis}

Tato kapitola se zabývá analýzou skriptování a nástrojů, které lze využít pro tvorbu skriptů. Zaměřuje se na skriptovací jazyk JavaScript a jeho použití v~Javovských aplikacích. Kapitola záměrně popisuje zejména skriptovací stroj Rhino a standardní skriptovací Java API, jež lze pro skriptování použít.

Skriptovací jazyky jsou programovací jazyky, které nám umožňují psát tzv. skripty. Na rozdíl od kompilovatelných zdrojových kódů, je kód skriptu vyhodnocován a interpretován tzv. virtuálním strojem -- za běhu skriptu. Většina skriptovacích jazyků je typována dynamicky za běhu skriptu, což nám umožnuje vytvářet proměnné bez specifikace typu, neboť typová konverze je prováděna automaticky. V dynamických jazycích můžeme použít jednu proměnnou pro uložení více typů. Skriptovací jazyky mají jednoduchou syntaxi, což umožňuje v určitých případech vyřešit poměrně složité problémy pomocí relativně krátkého kódu, efektivně a poměrně v krátkém čase.

Ačkoliv jsou skripty obvykle kompilovány za běhu skriptu, lze je zkompilovat do mezikódu Javy a nechat je vykonat JVM\footnote{JVM  (Java Virtual Machine) -- virtuální stroj Javy zpracovávající mezikód jazyka Java (Java bytecode)}. V~Javě bylo implementováno mnoho skriptovacích Jazyků, využívajících různá rozhraní pro skriptování, což bylo mj. i důvodem pro vznik obecného skriptovacího Java API (viz kapitola \ref{Chapter.JavaScriptInJavaAnalysis.ScriptingJavaAPI}). Mezi nejrozšířenější skriptovací jazyky pro Javu můžeme zařadit BeanShell, s velmi podobnou syntaxí jakou disponuje Java, a další implementace již existujících jazyků v~Javě jako je např. Jython -- implementace Pythonu,  JRuby -- implementace Ruby, Groovy aj.

Interpretů JavaScriptu implementovaných v~Javě běžících na JVM není mnoho. Z důvodu výkonnosti je většina interpretů JavaScriptu pro webové prohlížeče napsána nativně v~C nebo C++ a využívá JIT\footnote{JIT (Just in Time) -- metoda překladu urychlující běh skriptu překladem kódu do strojového jazyka} techniky. Jmenovitě nejznámější nativní javasriptová jádra jsou z rodiny „Monkey“, kterou spravuje společnost Mozilla, a která jsou postupně využívána ve webovém prohlížeči Firefox. Dalšími jádry ostatních webových prohlížečů je V8 použité v Google Chrome, Carakan v Opeře, Chakra v Iternet Exploreru nebo JavaScriptCore v~prohlížeči Safari.

Nejvíce používané interprety cílené pro Java aplikace máme v současnosti pouze tři. Nejznámějším interpretem je již zmíněné Rhino (kapitola \ref{Chapter.JavaScriptInJavaAnalysis.Rhino}) \cite{Bibliography.Rhino.Docs}, které je i dodáváno v~Oracle implementaci JDK\footnote{JDK (Java Development Kit) -- balík základních nástrojů potřebných pro vývoj aplikací pro platformu Java} 6 a 7, kde realizuje výchozí skriptovací stroj pro Javu. Dalším interpretem s velkým budoucím potenciálem, který bude součásti Oracle implementace JDK 8 a který je stále ve vývoji, je interpret Nashorn \cite{Bibliography.Nashorn.Project} (kapitola \ref{Chapter.JavaScriptInJavaAnalysis.Nashorn}). Oba zmíněné skriptovací jazyky implementují standardní skriptovací Java API. Rhino bylo o skriptovací API rozšířeno firmou Sun, kdežto Nashorn je vyvíjen s tímto API zprvu počátku. Posledním a nepříliš používaným interpretem je YAJI \cite{Bibliography.YAJI.Project}, který se snaží oživit starý interpret FESI \cite{Bibliography.FESI.Project} tím, že do něho přidává většinu vlastností z nejnovější specifikace ECMAScriptu.

\section{Rhino}
\label{Chapter.JavaScriptInJavaAnalysis.Rhino}

Rhino je implementace javasriptového jádra napsaná v programovacím jazyce Java. Projekt Rhina byl zahájen v roce 1997 firmou Netscape, kdy firma potřebovala integrovat podporu JavaScriptu do budoucího prohlížeče založeném na platformě Java. Rhino vzniklo portem nativní knihovny SpiderMonkey, takže i nyní si lze v kódu nevšimnout Javovských ekvivalentů nepodmíněných skoků. \cite{Bibliography.Rhino.History}

Projekt prohlížeče, tzv. Javagatoru, byl ovšem brzy pozastaven a Rhino zůstalo dále jen velmi pozvolna vyvíjené několika vlastníky, včetně společnosti Sun. V roce 1998 bylo Rhino uvolněno společnosti Mozilla a držitelé licencí se dohodli, že vydají Rhino jako svobodný software. Nyní je Rhino spravováno společností Mozilla. \cite{Bibliography.Rhino.History}

\subsection{Vlastnosti Rhina}
\label{Chapter.JavaScriptInJavaAnalysis.Rhino.RhinoFeatures}

V současnosti je vydáno Rhino s označením 1.7R4. Nejnovější verze implementuje všechny vlastnosti Javasriptu 1.7, tzn. je plně ekvivalentní s 3. vydáním standardu \linebreak ECMA-262 ECMAScript a přidává některé nové vlastnosti, jako jsou doplňky pro práci s poli a podpora E4X\footnote{Rozšíření programovacího jazyka ECMAScript, které přidává podporu nativního XML a vychází z normy ECMA-357 ECMAScript pro XML.}. Od verze 1.7R3 Rhino přidává i částečnou podporu Javasriptu 1.8 a 5. vydání ECMAScriptu, která byla nejnovější verzí 1.7R4 zejména optimalizována a jen mírně rozšířena. \cite{Bibliography.Rhino.v17R3,Bibliography.Rhino.v17R4}

Významnou předností Rhina je jeho dobrá provázanost s Javou. Napojení na jazyk Java a umožnění hostování objektů Javy nám zpřístupňuje z kódu JavaScriptu používat téměř libovolný balíček a třídu z Javy. Výjimky pro třídy, které by neměly být zpřístupňěny jsou definované bezpečnostními politikami ve třídě \texttt{SecurityManager} (Java API) a dodatečně třídou \texttt{ClassShutter} (knihovna Rhino). Jamile je přístup do třídy povolen, lze z kódu JavaScriptu tuto třídu konstruovat, volat její libovolnou metodu či přistupovat k~atributům třídy. Aby bylo možné objekt Javy v JavaScriptu používat, musí vždy implementovat rozhraní \texttt{Scriptable} (viz kapitola \ref{Chapter.JavaScriptInJavaAnalysis.Rhino.ScriptingWithRhino}).V případě hostování jazyka Javy, je rozhraní \texttt{Scriptable} implementováno automaticky pomocí třídy \texttt{WrapFactory}. 

Mezi další přednosti Rhina patří možnost rozdělení skriptů do modulů, tak jak bylo specifikováno skupinou CommonJS\footnote{CommonJS -- Skupina lidí snažící se vytvořit jednotné JavaScriptového prostředí pro servery, desktopy a prohlížeče.} a možnost vysledovat zdroj odkud skript pochází a zpracovávat skript podle odpovídající bezpečnostní politiky. Bezpečnostní politiky v Rhinu vycházejí z Netscape Navigatoru a jejich aplikace je založená na kontrole URL zdroje. \cite{Bibliography.Rhino.Overview}

Rhino umožňuje dva režimy -- interaktivní a kompilovaný. V kompilovaném módu je kód přeložen do mezikódu Javy a interpretován dále v JVM. V interaktivním módu je skript spouštěn jednoduchým interpretem, aniž by docházelo ke generování mezikódu Javy.

Poslední zajimavou vlastností knihovny Rhino je poskytování z kódu JavaScriptu podpory pro implementaci rozhraní a abstraktních tříd Javy. Implementaci nedefinovaných metod z JavaScriptu zajišťuje třída objektového adaptéru \texttt{JavaAdapter}. Adaptér vytváří pomocí reflexe objekty Javy a implementuje do objektů navíc metody rozhraní \texttt{Scriptable}, čímž zpřístupňuje tyto objekty pro přímé použití ve skriptech JavaScriptu. Adaptér můžeme buď přímo zavolat nebo ho nechat Rhino automaticky odvodit. 

%\begin{table}[ht] 
%    \texttt{\begin{tabbing}
%      	{ }{ }{ }{ }{ }\={ }{ }\=\+\kill
%      	// přímé zavolání adaptéru \\
%      	\textbf{var} arr1 = \textbf{new} JavaAdapter(java.util.ArrayList, {}); \\
%		// automatické odvození -- Rhino zavolá adaptér automaticky \\
%		\textbf{var} arr2 = \textbf{new} java.util.ArrayList();
%    \end{tabbing}}
%\end{table}
%\vspace{-12mm}
%\begin{algoritmus}
%	\caption{Demonstrace explicitního a implicitního volání adaptéru Javy}
%	\label{Algorithm.JavaAdapterInRhino}
%\end{algoritmus}

\subsection{Skriptování s Rhinem}
\label{Chapter.JavaScriptInJavaAnalysis.Rhino.ScriptingWithRhino}

Zdrojové kódy Rhina jsou strukturovány do několika hlavních balíků. Pro konstrukci skriptů v~Javě využijeme hlavně veřejné API z balíku \texttt{org.mozilla.JavaScript}.

Základním prvkem pro spuštění jakéhokoliv skriptu je objekt třídy Context, jenž nese vláknově specifické informace o prostředí pro běh skriptů. Každé programové vlákno, které vyžaduje spuštění skriptu, by si mělo asociovat vlastní kontext zavoláním \texttt{Context.enter()} a uvolnit zavoláním \texttt{Context.exit()}. \cite{Bibliography.Rhino.ScopesAndContexts}

Úložiště pro objekty nejvyšší úrovně nazýváme v~JavaScriptu jako tzv. scope. Do scopu vkládáme všechny vlastní objekty. Scope představuje jakousi množinu objektů. Objekt scopu je v Rhinu klasický JavaScriptový objekt, který implementuje třídu \texttt{Scriptable} a jenž by měl obsahovat základní stadardní objekty \texttt{Object} a \texttt{Function}. Inicializovaný scope můžeme získat zavoláním metody \texttt{initStandardObjects()} objektu kontextu. Důležitou vlastností scopu je, že je kontextově nezávislý, i přestože scope může být vytvořen z kontextu. Scope vytvořený jedním kontextem můžeme vyhodnotit s využitím jiného kontextu. Ve vícevláknových aplikacích lze nechat jeden scope vyhodnotit více odlišnými kontexty zároveň. Rhino zajištuje, že přístup k vlastnostem objektu je atomický. \cite{Bibliography.Rhino.ScopesAndContexts}

Objekty Javy, které chceme zpřístupnit do kódu skriptu, by měly implementovat rozhraní \texttt{Scriptable} a poskytnout metody pro práci s vlastnostmi objektu: \texttt{get()}, \texttt{put()}, \texttt{has()} a \texttt{delete()}. Základní implementaci rozhraní \texttt{Scriptable} a přístup k atributům objektu pomocí hashovací tabulky poskytuje v Rhinu třída \texttt{ScriptableObject}. Kromě toho třída \texttt{ScriptableObject} implementuje některé důležité metody pro definování hostovaných objektů z balíků Javy, jako je např. statická metoda \texttt{defineClass()}.

Posledním důležitým rozhraní je rozhraním \texttt{Function}. které je implementováno všemi funkčními objekty Javasriptu. Pokud chceme funkci zavolat, můžeme k tomu použít metody \texttt{call()} nebo \texttt{construct()} v závislosti na tom, jestli funkce má být volání s klíčovým slovem \texttt{new}.

JavaScript kromě základního objektu Object, který musí v~Javě implementovat již zmíněné rozhraní \texttt{Scriptable}, obsahuje i 5 primitivních datových typů. Tyto datové typy musí být mapovány do Javy na odpovídající třídy. Jakým způsobem je mapování docíleno, je znázorněné v tabulce \ref{Table.JavaScriptToJavaMapping}. 

\begin{table}[H]
  \begin{center} 
    \begin{tabular}{| c | l |} \hline
    \textbf{Typ v~JavaScriptu} & \textbf{Reprezentace v~Javě} \\ \hline
    \texttt{Undefined} & \texttt{org.mozilla.JavaScript.Undefined} \\ \hline
    \texttt{Null} & \texttt{null} \\ \hline
    \texttt{Boolean} & \texttt{java.lang.Boolean}  \\ \hline
    \texttt{Number} & \texttt{java.lang.Number} \\ \hline
    \texttt{String} & \texttt{java.lang.String} \\ \hline
    \end{tabular}
    \caption{Mapování primitivních typů JavaScriptu do Javy (XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX)}
    \label{Table.JavaScriptToJavaMapping}
  \end{center}
\end{table}

\subsection{Princip kompilátoru a interpretu}
\label{Chapter.JavaScriptInJavaAnalysis.Rhino.CompilerTechniques}

V předchozí kapitole jsme zmínili sadu nejdůležitějších tříd a rozhraní z veřejného API Rhina. V balíku \texttt{org.mozilla.JavaScript} se ovšem nachází i jednotlivé části zajišťující samotnou funkci překladače a interpretu JavaScriptu.

Mezi nejpodstatnější neveřejné třídy v balíku patří např. třída \texttt{ScriptRuntime} obsahující metody využívané interpretem a optimalizátorem jazyka pro generování mezikódu Javy. Formát mezikódu lze konkrétně nalézt v balíku \texttt{src.org.mozilla.classfile}. Překlad JavaScriptu do bajkódu probíhá běžně za běhu programu. Explicitní překlad skriptu a vytvoření .class souboru lze vynutit zavoláním překladače JavaScriptu, příkazem:

\medskip
\centerline{\texttt{java org.mozilla.JavaScript.tools.jsc.Main script.js}}
\medskip

Vlastní překladač do bajkódu Javy je velkým specifikem Rhina. Pro každý zkompilovaný skript je vygenerována přesně jedna odpovídající třída v~Javě, která implementuje rozhraní Script. Skript lze potom vykonat zavoláním metody \texttt{exec()} rozhraní Script.

Interaktivní (nekompilovaný) režim interpretu JavaScriptu zajišťuje třída \texttt{Interpret}, která je umístěná také v hlavním balíku. Interpret JavaScriptu v Rhinu je klasický zásobníkový automat. Pro reprezentaci mezikódu se používá instrukce s proměnlivou délkou. Instrukce se skládá z operačního kódu a případných operandů. Prováděcí smyčku interpretu implementuje metoda \texttt{interpretLoop()}, která přijímá aktuální rámec volání a kontext, ve kterém interpretování probíhá. Rámec volání obsahuje typické položky jako zásobník hodnot, pole symbolů a aktuální scope objekt.

Zajímavostí interpretu je zavedení dvou druhů zásobníků -- hlavního a číselného. Hlavní zásobník je určen pro obecné hodnoty, tzn. pro hodnoty všech typů JavaScriptu. Číselný zásobník slouží pro uložení hodnot JavaScriptového primitivního typu \texttt{Number}. Hlavní zásobník je implementován v~Javě jako pole objektů \texttt{Object} a číselný jako pole primitivního typu \texttt{double}. Mezi hlavním a číselným zásobníkem probíhá mapování. Pokud je v hlavním zásobníku uložená unikátní hodnota \texttt{DBL\_MRK}, tak bude čtení odpovídajících hodnot pokračovat ve druhém zásobníku (viz obrázek \ref{Figure.RhinoStack}). Tato technika byla zavedena čistě z důvodu optimalizace, aby nedocházelo ke zbytečnému \csuv{zabalení} primitivního typu do objektu a aby se šetřila alokace paměti pro objekt a příp. dereference ukazatelů.

\begin{figure}[H]
  \begin{center}
    \scalebox{0.40}{
      \includegraphics{fig/rhino_stack.pdf}
    }
    \caption{Znázornění koexistence hlavního a číselného zásobníku}
    \label{Figure.RhinoStack}
  \end{center}
\end{figure}

Interpret JavaScriptu přijímá mezikód jazyka, který je generován metodou compile třídy \texttt{CodeGenerator}. Generátor mezikódu pracuje s abstraktním syntaktickým stromem tvořeným z prvků definovaných v balíku \texttt{org.mozilla.JavaScript.ast} a generovaným třídou \texttt{Parser}.

\section{Nashorn}
\label{Chapter.JavaScriptInJavaAnalysis.Nashorn}

Nashorn je projekt, který si klade za cíl vyvinout zcela nový, odlehčený a výkonný JavaScriptový runtime pro nativní JVM. Výstupem projektu by měla být schopnost spouštět JavaScriptový kód příkazem jrunscript, která podléhá specifikaci JSR 223\footnote{JSR 223 -- specifikace definující framework pro vkládání skriptů do zdrojového kódu Javy}. Oproti poměrně letitému JavaScriptovému interpretu Rhina vyvinutému pro tehdejší JVM, se Nashorn zaměřuje na nové techniky používání dynamických jazyků v~Javě a vychází ze specifikace \linebreak tzv. Da Vinci stroje (JSR 292\footnote{JSR 292 -- specifikace pro rozšíření JVM o nativní podporu dynamických jazyků}). \cite{Bibliography.Nashorn.Project}

Jádro interpretu Nashorn vychází z ECMAScriptu verze 5.1. Skripty jazyka JavaScript lze v~Javě vytvářet užitím klasického Java API pro skriptování popsaného blíže v kapitole \ref{Chapter.JavaScriptInJavaAnalysis.ScriptingJavaAPI}. Konkrétní instanci JavaScriptového jádra \texttt{ScriptEngine} získáme vyhledáním odpovídajícího slova např. „nashorn“ v továrně \texttt{ScriptEngineManager}. Naopak pokud chceme spustit JavaScriptový skript, můžeme toho dosáhnout příkazem jrunscript a specifikací skriptovacího jazyka přepínačem \texttt{-l}, předáním skriptu přepínačem \texttt{-e}, nebo souboru se skriptem přepínačem \texttt{-f}.

\section{Skriptovací Java API}
\label{Chapter.JavaScriptInJavaAnalysis.ScriptingJavaAPI}

V Javě byly postupem času implementovány všechny nejznámější skriptovací jazyky používající různá a vlastní rozhraní. To bylo základním podmětem pro vytvoření obecného a přenositelného skriptovacího Java API, které umožňuje propojit skripty s aplikací Javy. API muselo být napsáno velmi abstraktně, aby bylo aplikovatelné na jakýkoliv rozmanitý skriptovací stroj, ale zároveň muselo zahrnout všechny specifické aspekty známých skriptovacích jazyků. \cite{Bibliography.JavaAPI.Script.Book}

Skriptovací Java API vychází ze specifikace JSR 223. Tato specifikace definuje standardní framework a API pro tvorbu skriptu a jejich vkládání do Javovských aplikací. Specifikace ovšem nedefinuje jaký jazyk pro skriptování musíme zvolit. Proto můžeme použít pro skriptování jakýkoliv jazyk, který je kompatibilní s JSR 223. Použitím standardního API máme možnost psát skripty kompatibilní s JSR 223. A naopak při psaní skriptu, který je kompatibilní s JSR 223, máme garantováno, že budeme mít přístup k jakékoliv standardní Java knihovně.

Implementace Java API v JDK od Oraclu vychází z frameworku BSF \cite{Bibliography.BSF.Framework}. Tento framework byl vyvinut firmou IBM a ve verzi 2.x poskytoval základní množinu tříd umožňujících podporu skriptovacích jazyků v aplikacích Javy. S příchodem skriptovacího Java API byl vydán BSF framework verze 3.x, který se poté stal součástí zmíněného JDK.

Základní Oracle implementace JDK 6 a 7 skriptovacího API obsahuje upravený již zmíněný JavaScriptový stroj vycházející z knihovny Rhina. Zahrnutá Oracle verze knihovny Rhina byla omezena o některé vlastnosti, které by poskytovalo přímé použití knihovny. Z důvodu bezpečnosti byl zakázán kompilátor do mezikódu Javy. V JDK nelze najít ani pomocné nástroje příkazové řádky distribuované Rhinem od Mozilly, jako jsou např.: JavaScriptový shell, debugger apod. Použitá implementace Rhina umožňovala definovat abstraktní třídy a implementovat vícenásobná rozhraní pomocí adaptéru JavaAdapter. Oracle nahradil tento adaptér vlastní třídou, která umožňuje implementaci pouze jednoduchých rozhraní. 

\subsection{Architektura skriptování}
\label{Chapter.JavaScriptInJavaAnalysis.ScriptingJavaAPI.ArchitectureOfScripting}

\bigskip \noindent Skriptovací API je umístěné v balíčku \texttt{javax.script}. Skriptování je poměrně přímočaré. Abychom mohli začít psát skripty, vždycky nejprve musíme:

\begin{enumerate}
  \item Vytvořit objekt třídy \texttt{ScriptEngineMager} -- objekt vyhledává skriptovací enginy \texttt{ScriptEngine} v načtených JAR knihovnách, je to tzv. továrna na skriptovací enginy;
  \item Získat instanci skriptovacího enginu \texttt{ScriptEngine} -- instance skriptovacího enginu je získána z továrny zavoláním např. metody \texttt{getEngineByName()}. 
\end{enumerate}

Jakmile máme získanou instanci skriptovacího enginu, můžeme již vykonávat, definovat, nebo upravovat skripty.

Nejdůležitější metodou rozhraní \texttt{ScriptEngine} je bezpochyby metoda \texttt{eval()}, která nám umožní spouštět skripty. Skript může být předán jako řetězec, nebo může být umístěn v~souboru, streamu, či jiném zdroji. V závislosti na tom, zda daný skriptovací jazyk umožnuje vyhodnocování skriptu s výsledkem, tak je metoda \texttt{eval()} vrácí i výsledek skriptu.

Myšlenkou Java API je mít co nejvíce společných rysů skriptovacích jazyků specifikovaných v rozhraní \texttt{ScriptEngine} a nemít zde žádný rys, který by některý skriptovací jazyk nemohl poskytnout. Proto všechny speciální vlastnosti konkrétních skriptovacích jazyků musí být implementovány v odlišných rozhraních. Tento návrh zajišťuje minimum změn těchto rozhraní v budoucnu. 

\bigskip \noindent Nejdůležitější přídavnými rozhraními rozpoznáváme:

\begin{itemize}
  \item \textbf{\texttt{Invocable}} -- rozhraní implementované enginy, které umožňují volat funkce/metody ve skriptu. Pro volání funkce používáme \texttt{invokeFunction()}, pro metody invokeMethod();
  \item \textbf{\texttt{Compilable}} -- rozhraní implementované enginy, které jsou schopny kompilovat skript do svého mezikódu.
\end{itemize}

\subsection{Data binding}
\label{Chapter.JavaScriptInJavaAnalysis.ScriptingJavaAPI.DataBinding}

Důležitým úkolem pro funkci frameworku Java API, je zajistit sdílení dat mezi hostovanou aplikací Javy a skriptovacím strojem. Framework BSF umožňoval sdílení proměnných pouze po náležité registraci v manažeru skriptovacích enginů, k němuž měly přístup všechny skriptovací enginy. Java API model data bindingu dále vylepšuje tím, že udržuje sdílené proměnné pomocí kontextu, ve kterém je skript spouštěn.

Proměnné jsou seskupeny a uloženy ve jmenných prostorech neboli scopech. Abstrakce uchovávání proměnných ve scopu je dána rozhraním \texttt{javax.script.Bindings}, přičemž se nejedná o nic jiného, než o jednoduché mapování názvu proměnné na náležitý objekt -- \texttt{Map<String, Object>}. Každý kontext skriptu obsahuje právě množinu takovýchto jmenných prostorů.

\bigskip \noindent Specifikace uvádí dva základní jmenné prostory:

\begin{itemize}
  \item \textbf{Enginový scope} -- proměnné, které se vážou k tomuto scopu nejsou viditelné jiným strojem;
  \item \textbf{Globání scope} -- ke všem proměnným tohoto scopu mají přístup všechny enginy vytvořené danou instancí enginového manažeru.
\end{itemize}

Pokud chceme vytvořit novou proměnnou, dosáhneme toho zavoláním metody \texttt{put()} objektu \texttt{Bindings}. Proměnnou v enginovém scopu lze definovat následovně:

\begin{enumerate}
  \item Nastavením vlastního objektu \texttt{Bindings} -- vytvořit mapovací objekt Bindings, kde vytvoříme naši proměnnou. Tento mapovací objekt nastavíme v enginu buď metodou \texttt{setBindings()}, nebo případně až za běhu skriptu parametrem v metodě \texttt{eval()};
  \item Využitím enginového objektu \texttt{Bindings} -- získáme výchozí mapovací objekt enginu metodou \texttt{getBindings()}, do kterého následně vložíme naši proměnnou.
\end{enumerate}

Získání hodnoty proměnné se docílí obdobně pouze metodou \texttt{get()}.

Základní vlastností frameworku je uchovávání stavu proměnných po vykonání skriptu. Všechny proměnné, které jsou ve skriptu inicializovány, se také automaticky vloží do odpovídajícího objektu \texttt{Bindings}. Po skončení skriptu jsou vytvořené proměnné dostupné v~odpovídajícím scopu, kde byly vytvořeny. Tento stav scopu zůstává i do dalšího vyhodnocení metodou \texttt{eval()}.

Jmenné prostory jsou pouze jedním stavebním prvkem třídy \texttt{SimpleScriptContext} -- kontextu skriptu. Všechny stavové objekty, které jsou pro běh skriptu podstatné, jsou uložené právě v této třídě. Dokonce i výše popsaný globální a enginový scope je uchováván zde. Jmenné prostory jsou zde uloženy ve formě listu čísel, které identifikují jednotlivé scopy. Čísla ve skutečnosti představují prioritu scopu. Nízká čísla popisují scopy s vysokou prioritou a vysoká čísla s nízkou prioritou. Ve vyhodnocování skriptu to znamená, že pokud např. hledáme proměnnou, která je ve dvou scopech zároveň, tak bude navrácena pouze ta proměnná ze scopu, který má vyšší prioritu. Enginovému scopu je přiřazena priorita 100, globálnímu scopu priorita 200. Kromě dvou základních scopů si můžeme definovat i vlastní jmenný prostor. Pro vytvoření vlastního jmenného prostoru ovšem nestačí nastavit tento scope pomocí \texttt{setBindings()} ve třídě \texttt{SimpleScriptContext}, protože třída přijímá pouze dva základní kontexty. Proto musíme definovat svůj vlastní kontext implementující rozhraní \texttt{ScriptContext}.

\chapter{Návrh}
\label{Chapter.Design}

Dle zadání této práce máme implementovat podporu pro klientský JavaScript do experimentálního vykreslovacího stroje CSSBox napsaném v jazyku Java. Výsledná aplikace by měla být opět psána v čistém jazyce Java bez použití nativních knihoven, tudíž by neměla narušovat přenositelnost stroje CSSBox.

Z  analýzy problematiky jednotlivých existujících strojů JavaScriptu v jazyce Java víme, že v současné době nemáme příliš mnoho na výběr. Jediným použitelným řešením pro skriptování, zejména z důvodu podpory hostování objektů Javy ve skriptech JavaScriptu, je pouze knihovna Rhino. Aby se v budoucnu ovšem dalo lehce přejít případně na jiný JavaScriptový stroj, budeme pro implementaci podpory klientského JavaScriptu používat a skriptování z jazyka Javy výhradně standardní skriptovací Java API.

V návrhu se konkrétně zaměříme na problematiku zpracování skriptů z HTML dokumentu (kapitola \ref{Chapter.Design.ScriptsInHTML}) a uvedeme možnost jak zařadit podporu pro skriptování do projektu SwingBox (viz kapitola \ref{Chapter.Design.ScriptsInSwingBox}). V kapitole \ref{Chapter.Design.GlobalScopeInjections} naznačíme techniku automatických instalací rozšíření do hlavního scopu JavaScriptu. Kapitola \ref{Chapter.Design.JavaScriptEngineJSR223} se bude zabývat spíše experimentální problematikou a to implementací základního zabezpečení do skriptovacího stroje Rhino. V závěru návrhu (kapitola \ref{Chapter.Design.SwingBoxIntegration}) budeme demonstrovat integraci rozšíření klientského JavaScriptu do projektu SwingBox.

Návrh byl proveden s ohledem na již existující třídy projektu CSSBox a ostatních knihoven. Návrh vychází z veřejných rozhraní tříd a není-li to zapotřebí, tak se nesnaží již existující třídy znovu implementovat. 

\bigskip \noindent Očekávanými závislostmi projektu budou knihovny a projekty:

\begin{itemize}
  \item \textbf{CSSBox} \cite{Bibliography.CSSBox} -- (X)HTML renderovací knihovna,
  \item \textbf{CSSParser} \cite{Bibliography.jStyleParser} -- parser kaskádových stylů,
  \item \textbf{SwingBox} \cite{Bibliography.SwingBox} -- prohlížeč webových stránek využívající CSSBox,
  \item \textbf{Rhino} \cite{Bibliography.Rhino.Docs} -- skriptovací stroj JavaScriptu,
  \item \textbf{Google Juice} \cite{Bibliography.Google.Juice} -- pro umožňění injektáže závislostí (angl. dependency injection),  
  \item \textbf{NekoHTML} \cite{Bibliography.NekoHTML} -- parser HTML dokumentu,
  \item \textbf{Apache CXF} \cite{Bibliography.Apache.CXF} -- knihovna klient/server služeb.
\end{itemize}

Projekt bude vyvíjen na systému Windows 8 v prostředí Eclipse s JDK 1.7.0\_25. Za cíl si projekt klade poskytnout zpětnou podporu pro JRE/JDK 6.
 
\section{Provádění skriptů v HTML dokumentu}
\label{Chapter.Design.ScriptsInHTML}

Klientské skripty jsou v HTML dokumentu specifikovány elementy \texttt{<script>}. Jak bylo uvedené v kapitole \ref{Chapter.DependenciesAnalysis.ScriptsInHTML}, lze skripty vykovávat ihned po dokončení parsování značky se skriptem a nemusí se čekat, dokud je celý dokument načten. 

V současné době není v~rámci projektu CSSBox podpora pro manipulaci s dokumentem, který je právě čten. Aby bylo možné implementovat podporu pro skriptování přesně podle HTML specifikace, budeme muset implementovat vlastní parser dokumentu. Základní navrženou techniku implementace parseru dokumentu lze spatřit na obrázku \ref{Figure.EventDOMParserDesign}.

\begin{figure}[H]
  \begin{center}
    \scalebox{0.65}{
      \includegraphics{fig/org-fit-cssbox-jse-document.pdf}
    }
    \caption{Diagram tříd parseru dokumentu \texttt{EventDOMParser}}
    \label{Figure.EventDOMParserDesign}
  \end{center}
\end{figure}

Podle návrhu bude nutno definovat vlastní parser \texttt{EventDOMParser}, který vychází z parseru \texttt{DOMParser} knihovny NekoHTML. Tento parser bude průběžně zpracovávat vstupní dokument a informovat o aktuálním stavu parsování pomocí speciálních událostí. Události budou nést informaci, zda bylo zahájeno či ukončeno parsování určitého uzlu. Pokud parsování bylo dokončeno, bude si moci naslouchající objekt vyzvednout rozparsovaný uzel. 

Knihovní třída \texttt{DOMParser} využívá pro vytváření dokumentu implementované rozhraní \texttt{XMLDocumentHandler}, které obsahuje obslužné metody informující o stavu parsování. V~rámci těchto obslužných metod dochází k vytváření jednotlivých uzlů dokumentu a konstruování výsledného stromu dokumentu. Současnou implementaci objektu, který zajišťuje konstrukci stromu dokumentu lze získat z konfigurace parseru.

Odchytávání událostí během parsování bude umožněno přenastavením aktuální implementace instance třídy \texttt{XMLDocumenthandler} v konfiguraci parseru \texttt{DOMParser}. Naším cílem bude v rámci volání obslužných metod zavolat i naši vlastní událost. Abychom ovšem nemuseli předefinovat celou funkčnost konstrukce dokumentu, budeme využívat starý knihovní \texttt{XMLDocumentHandler} získaný z konfigurace. Upravený \texttt{EventXMLDocumentHandler} bude knihovní handler pouze dekorovat a zajišťovat propagaci některých události výše do třídy \texttt{EventDOMParser}. 

Aby byl návrh kompletní, byla navržena i třída \texttt{NodeEventDispatcher} vykonávající události \texttt{NodeEvent}. Všichni zájemci o naslouchání událostí si budou muset zaregistrovat naslouchající objekt ve třídě \texttt{EventDOMParser}, který dále tento objekt zaregistruje i ve třídě \texttt{NodeEventDispatcher}. Objekty odchytávající události parseru budou implementovat rozhraní \texttt{NodeEventListener} vycházející ze standardního rozhraní Javy \texttt{EventListener}.

\section{Podpora skriptování v projektu SwingBox}
\label{Chapter.Design.ScriptsInSwingBox}

Jak bylo popsáno v kapitole \ref{Chapter.DependenciesAnalysis.SwingBox}, projekt SwingBox umožňuje zobrazovat a procházet webové stránky. Pro přidání podpory skriptování do tohoto projektu (viz kapitola \ref{Chapter.Design.SwingBoxIntegration}) bude nutno definovat vlastní třídu \texttt{CSSBoxAnalyzer}. SwingBox používá tuto třídu pro parsování vstupního dokumentu a převod dokumentu na vykreslovaný \texttt{ElementBox}.   

\begin{figure}[H]
  \begin{center}
    \scalebox{0.75}{
      \includegraphics{fig/org-fit-cssbox-jse-util.pdf}
    }
    \caption{Diagram tříd znázorňující podporu JavaScriptu v projektu SwingBox}
    \label{Figure.ScriptsInSwingBoxDesign}
  \end{center}
\end{figure}

Projekt \texttt{CSSBox} definuje pro zdroj dokumentu třídu \texttt{DocumentSource}, pro čtení dokumentu ze zdroje dokumentu třídu \texttt{DOMSource}. Abychom jsme se drželi zavedené praktiky pro čtení dokumentu s událostmi, v návrhu definujeme třídu \texttt{EventDOMSource}, která pouze vnitřně používá v kapitole \ref{Chapter.Design.ScriptsInHTML} popsaný \texttt{EventDOMParser}. 

Největší roli při invokaci skriptu hraje v návrhu \texttt{ScriptAnalyzer}, který má u událostního parseru zaregistrovaný vlastní \texttt{EventNodeListener}. Při příchodu události o zpracování elementu \texttt{<script>}, přečte \texttt{ScriptAnalyzer} skript v jeho těle, případně načte skript z URL adresy uvedené v \texttt{src} atributu. Pokud skript neobsahoval atribut \texttt{defer}, tak se dále nechá ihned vykonávat ve stroji \texttt{DocumentScriptEngine}. Stroj, který má být použit pro aktuální skript je získán z instance třídy \texttt{DocumentScriptManager} na základě atributu \texttt{type} elementu \texttt{<script>}, nebo z výchozího uvedeného stroje v \texttt{<meta>} značce (viz kapitola \ref{Chapter.DependenciesAnalysis.ScriptsInHTML}).

\begin{figure}[H]
  \begin{center}
    \scalebox{0.55}{
      \includegraphics{fig/javascsript-engine.pdf}
    }
    \caption{Diagram abstraktní třídy \texttt{DocumentScriptEngine}}
    \label{Figure.DocumentScriptEngineDesign}
  \end{center}
\end{figure}

Pokud je skript vykováván poprvé v rámci uvedeného dokumentu, tak dojde u třídy \texttt{DocumentScriptEngine} (obrázek \ref{Figure.DocumentScriptEngineDesign}) i k zavolání metody \texttt{initScriptEngine()}, která vytvoří globální scope pro vykonávání skriptů. V globální scopu jsou poté vykonávány všechny skripty na stránce. Skriptovací stroj uchovává jednotlivé zaregistrované dokumenty a jejich vykonávací globální scopy dokud není webová stránka přenačtena a dokument není změněn. O zničení dokumentu bude stroj informován metodou \texttt{stopScriptEngine()}.

\section{Injektování objektů do hlavního scopu}
\label{Chapter.Design.GlobalScopeInjections}

Během implementace podpory klientského JavaScriptu do projektu CSSBox se
předpokládá vytvoření velkého množství tříd, které budou implementovat
jednotlivé aspekty JavaScriptu pro prohlížeč. Předpokládá se, že vyvíjené třídy budou vyvíjeny postupně a iterativně přidávat jednotlivé funkčnosti. Bylo by výhodné oddělit jednotlivé nové funkce a odstranit potřebu přímého zásahu do třídy \texttt{DocumentScriptEngine} s příchodem nového rozšíření.

\begin{figure}[H]
  \begin{center}
    \scalebox{0.75}{
      \includegraphics{fig/org-fit-cssbox-jse-script-inject.pdf}
    }
    \caption{Diagram tříd znázorňující podporu injektování rozšíření JavaScriptu}
    \label{Figure.GlobalScopeInjectionsDesign}
  \end{center}
\end{figure}

K separaci nových implementovaných vlastností JavaScriptu byla navržena technika injekce funkčnosti do vytvořeného kontextu (obrázek \ref{Figure.GlobalScopeInjectionsDesign}). Pro přidání nové funkčnosti do globálního scopu kontextu bude nutno implementovat abstraktní třídu \texttt{ScriptContextInject}. Samotnou injekci do globálního scopu bude provádět metoda \texttt{inject()}. Aby skriptovací stroj věděl, jaká rozšíření má injektovat do svého scopu, měla by být jednotlivá rozšíření registrována u skriptovacího stroje metodou \texttt{installContextInject()}. Injekce bude prováděna vždy po vyhodnocení některého skriptu, nebo po inicializování nového dokumentu. Pořadí jednotlivých injekcí bude v základní implementaci určovat metoda \texttt{getPriority()}. Zda je injekce validní, tudíž proveditelná, bude získáváno metodou \texttt{isValid()}. Příkladem, kdy injekce by byla neproveditelná, by mohla být např. situace, kdy není ještě dokument úplně načten a některé rozšíření by záviselo právě na existenci dokumentu.

Neustálá instalace nové injekce rozšíření do skriptovacího stroje s příchodem nového rozšíření by se postupem času nejevila jako dobré řešení. Bylo by výhodné, aby s novým rozšířením došlo i k automatické instalaci tohoto rozšíření do skriptovacího stroje, tzn., abychom dosáhli obrácení řízení -- IoC (Inversion of Control). Pro tento účel byla navržena třída \texttt{ScriptContextInjector}, která kromě metod samotné injekce bude provádět i registraci rozšíření v odpovídajícím skriptovacím stroji. Bude-li to implementačně vhodné, k získání reference registru skriptovacích strojů \texttt{DocumentScriptManager} z objektů ScriptContextInjector se bude používat injektáž závislosti -- DI (Dependency Injection). Pro podporu DI je v plánu použít knihovnu Google Juice. Ve třídě \texttt{ScriptContextInjector} se v závislosti na typu skriptu vyhledá v registru skriptovacích strojů odpovídající stroj, ve kterém proběhne registrace samotné injekce rozšíření. 

Pokud celý návrh injektování shrneme, tak automatická registrace injekce rozšíření bude probíhat v abstraktní třídě \texttt{ScriptContextInjector}. O tom, do jakého skriptovacího stroje by se měla injekce rozšíření vložit, bude informovat pro jazyk JavaScript např. třída injektoru \texttt{JavaScriptContextInjector}. Samotná injekce rozšíření bude přitom implementována až specifickými injektory, jako jsou např. \texttt{XMLHttpRequestInjector}, \texttt{ConsoleInjector}, apod.

\section{Implementace stroje JavaScriptu podle normy JSR 223}
\label{Chapter.Design.JavaScriptEngineJSR223}

Poslední iterací v integraci JavaScriptového stroje do projektu CSSBox by bylo přizpůsobit skriptovací stroj tak, aby splňoval bezpečnostní předpoklady pro běh v prohlížeči. Budeme muset zabránit zejména přístupu do tříd a balíků Javy, které nenesou žádnou funkční hodnotu pro implementaci klientského JavaScriptu. Z důvodu snazšího přechodu na jiný skriptovací stroj, např. Nashorn, by bylo výhodné, aby byl stroj implementován podle standardu JSR 223. Nashorn je vyvíjen se standardním rozhraním již od základu.

Pro tvorbu takového stroje by se nabízelo využít již existující stroj implementovaný v~Java API, který se nachází v balíku sun.org.mozilla.JavaScript. Třídy Java API jsou ovšem finální, nebo skryty, což brání jejich znovupoužití. Nezbývá nám než implementovat vlastní skriptovací stroj, který rozšiřuje základní třídu pro skriptovací stroje AbstractScriptEngine. Tento stroj bude pro implementaci samotného skriptování využívat externí knihovnu Rhino. Rozhodnutí pro dodání externí knihovny bylo učiněno z důvodu, abychom nebyli závislí na knihovně, která je dodávaná v JDK v balíku \texttt{sun.org.mozilla.JavaScript.internal}. Osamostatněním na implementaci JDK získáme kompletní správu nad verzí knihovny a nebudeme muset řešit případné problémy s příchodem JDK 8, kde již Rhino zřejmě nebude ani v rámci základní distribuce JDK.

Způsob, kterým by mohl být implementován JavaScriptový stroj s implementovanými bezpečnostními funkcemi je navržen na obrázku \ref{Figure.JavaScriptEngineJSR223Design}:

\begin{figure}[H]
  \begin{center}
    \scalebox{0.80}{
      \includegraphics{fig/org-fit-cssbox-jse-script.pdf}
    }
    \caption{Diagram tříd zabezpečeného skriptavacího stroje JavaScriptu}
    \label{Figure.JavaScriptEngineJSR223Design}
  \end{center}
\end{figure}

Skriptovací stroj spravující jednotlivé načtené webové dokumenty reprezentovaný třídou \texttt{JavaScriptDocumentEngine} bude používat instanci námi upraveného skriptovacího stroje nazvaného \texttt{RestrictedRhinoScriptEngine}. Aby byla splněna specifikace JSR 223, tak bude tento stroj vytvářen pomocí továrny, která bude realizovat abstraktní třídu Java API \texttt{ScriptEngineFactoryBase}. Třída \texttt{RestrictedRhinoScriptEngine} bude muset implementovat abstraktní třídu pro všechny skriptovací stroje \texttt{AbstractScriptEngine}. Jelikož JavaScript umožňuje i volat funkce, tak bude dodatečně implementováno i rozhraní \texttt{Invocable}. 

Námi implementovaný stroj bude staticky vytvářet objekty nejvyšší úrovně a standardní objekty JavaScriptu, které budou společné pro globální scope a pro každé vykonávání skriptu. Staticky bude vytvořena i továrna \texttt{JavaShutterContextFactory} pro vytváření kontextu, která implementuje \texttt{ContextFactory}. Továrna je automaticky volána knihovnou Rhino pokaždé, když vstoupíme do nového kontextu metodou \texttt{Context.enter()}. Továrna kontextu bude instalovat do kontextu vlastní obalující továrnu \texttt{ShutterWrapFactory} a objekt třídy \texttt{JavaShutter} sloužící pro omezení přístupu do jazyka Javy. Objekt omezující bezpečnost bude viditelný i z továrny pro obalování objektů Javy.

Důvodem pro předefinování továrny obalující objekty, která je volána pro každou třídu, objekt, metodu, primitivní typ Javy použitý v kódu JavaScriptu, je právě přidání podpory rozmělnění bezpečnosti. Samotným účelem obalující továrny je dodání rozhraní \texttt{Scriptable} do objektů Javy, tak aby byly viditelné z kódu JavaScriptu. Ve vlastní implementaci továrny budeme provádět před obalením položky ověření, zda je položka viditelná. Pokud položka nemá být viditelná, tak nedojde k požadovanému obalení položky, takže položka z kódu JavaScriptu nebude viditelná.

Knihovna Rhino již obsahuje rozhraní \texttt{ClassShutter} pro zajištění bezpečnosti přístupu do Javy. Rozhraní \texttt{ClassShutter} však obsahuje pouze jednu metodu, která ověří, zda je požadovaná třída viditelná. Navrhnutá architektura na obrázku \ref{Figure.JavaScriptEngineJSR223Design} ovšem uvádí rozmělnění zabezpečení do menších položek, jako jsou povolené metody, atributy aj. Takovéto rozmělnění bude zajištěno objektem \texttt{JavaShutter}, který bude poskytovat informaci o tom, zda je přistupovaná třída, metoda, vlastnost apod. viditelná z kódu JavaScriptu. Registrace viditelných položek bude implementačně prováděna manuálně zavoláním určité metody nad objektem \texttt{JavaShutter}. Budeme mít ale i možnost nechat viditelnost odvodit automaticky podle anotace položky. Pro viditelné položky Javy zavedeme vlastní anotaci \texttt{@JSVisible}. 

Druhým bezpečnostním omezením bude omezení adaptéru zabezpečujícího implementaci rozhraní a abstraktních tříd Javy -- \texttt{JavaAdapter}. Předpokládá se, že tato funkčnost bude kompletně zakázána.

Po vyřešení bezpečnosti budeme muset implementovat samotné propojení rozhraní Rhina a specifikace JSR 223. Důležité bude vyřešit data binding pro kontext \texttt{ScriptContext} definovaný v této specifikaci. Abychom měli přehled o všech proměnných, které se ve hlavním scopu nachází, budeme muset vytvořit třídu vlastního scopu. Scope (viz kapitola \ref{Chapter.JavaScriptInJavaAnalysis.Rhino.ScriptingWithRhino}) je klasický JavaScriptový objekt, ve kterém probíhá spouštění skriptu, tudíž implementuje rozhraní \texttt{Scriptable}. Rozhraní specifikuje metody pro zápis \texttt{put()} a získání atributů \texttt{get()} z objektu. Tyto metody jsou během vykonávání skriptu náležitě volány. Zpětného volání metod využijeme k navázání atributů do objektu \texttt{Bindings} a nebo získání atributů z objektu \texttt{Bindings}. 

Výše popsané praktiky jsou dostatečné pro vytvoření jednoduchého stroje, který vychází ze specifikace JSR 223.  Po zavolání vykonání skriptu metodou \texttt{eval()}, bude pracovat stroj tak, jak je popsáno v následujících krocích:  

\begin{enumerate}
  \item	Vytvoří se nový kontext zavoláním \texttt{Context.enter()}, v rámci něhož dojde i k zavolání metody \texttt{makeContext()} třídy \texttt{JavaShutterContextFactory};
  \item	Vytvoří se nový hlavní scope, který bude nastavovat a číst \texttt{Bindings} objekt;
  \item	Do hlavního scopu se vloží standardní a globální objekty, které budou společné pro všechny skripty. Vložení proběhne nastavením prototypu hlavního scopu;
  \item	Spustí se skript nad vytvořeným kontextem a hlavním scopem.
\end{enumerate}

\section{Integrace podpory JavaScriptu do SwingBoxu}
\label{Chapter.Design.SwingBoxIntegration}

Všechny potřebné náležitosti pro zařazení podpory JavaScriptu do projektu CSSBox byly již navrženy. Návrh proběhl konkrétně pro podprojekt SwingBox, který rozšiřuje výchozí  CSSBox o reakci prvků stránky na podněty příchozí od uživatele, tzn. zejména o možnost procházení webového obsahu. 

Aby bylo možné zakomponovat JavaScript do projektu SwingBox, bude nutno provést registraci vlastní \texttt{CSSBoxAnalyzer} třídy navržené v kapitole \ref{Chapter.Design.ScriptsInSwingBox}. Kompletní konfigurace, kterou bude nutno provést pro přidání podpory JavaScriptu je znázorněna na obrázku \ref{Figure.SwingBoxIntegrationDesign}.

\begin{figure}[H]
  \begin{center}
    \scalebox{0.80}{
      \includegraphics{fig/swingbox-integration.pdf}
    }
    \caption{Sekvenční diagram znázorňující kroky integrace JavaScriptového stroje}
    \label{Figure.SwingBoxIntegrationDesign}
  \end{center}
\end{figure}

Z uvedeného diagramu je patrné, že pouhá jedna registrace vlastního vyhodnocovače dokumentu \texttt{ScriptAnalyzer} bude pro přidání podpory JavaScriptu dostačující. Projekt SwingBox zejména implementuje vlastní zobrazovací plochu pro webové stránky \texttt{BrowserPane}. Zobrazovací plochu využijeme ve finální čísti projektu pro tvorbu jednoduchého webového prohlížeče a znázornění funkčnosti skriptování v HTML dokumentech. Třída pro zobrazování obsahu HTML stránky využívá pro veškeré čtení nového dokumentu webové stránky třídu \texttt{SwingBoxEditrKit}, která následně volá \texttt{ContentReader}, jenž je přímo spjat s~aktuálně zaregistrovaným \texttt{CSSBoxAnalyzer}. Definicí vlastní třídy \texttt{ScriptAnalyzer} získáme plnou kontrolu nad zpracovávaným dokumentem a možnost provádění skriptů v HTML dokumentu. 

\chapter{Implementace}
\label{Chapter.Implementation}

Následující kapitola pojednává o realizaci rozšíření projektu CSSBox o možnost provádění skriptů v (X)HTML dokumentech (kapitola \ref{Chapter.Design}). Popis implementace je zaměřen na uvedení nejzákladnějších tříd, metod či funkcí, které implementují nejdůležitější části výsledné aplikace, přičemž podrobný popis lze nalézt v programových dokumentacích na přiloženém DVD (příloha \ref{Annex.dvdContent}).

Cílem implementace bylo přidat podporu pro skriptování v (X)HTML dokumentech a zahrnout podmnožinu aktuální specifikace klientského JavaScriptu. Aby bylo možné implementovat klientské skriptovací enginy, bylo zapotřebí vytvořit jednoduché jádro prohlížeče implementující základní aspekty procházení stránek (kapitola \ref{Chapter.Implementation.BrowsingCore}). Pro snadné přidávání nových klientských skriptovacích enginů byla vytvořena abstraktní architektura pro skriptování (kapitola \ref{Chapter.Implementation.BrowsingCore}), ze které vychází i JavaScriptový klientský engine (kapitola \ref{Chapter.Implementation.JavaScriptEngine}).

Implementace této práce se nachází v podbalících hlavního balíku projektu ScriptBox pojmenovaném \texttt{org.fit.cssbox.scriptbox}.  Názvy tříd, které tyto podbalíky obsahují, nebudou v této kapitole z důvodu zjednodušení a přehlednosti plně kvalifikovány. Stručné popisy jednotlivých balíků jsou v příloze \ref{Annex.packageDescription}.

\section{Jádro prohlížeče a jeho rozhraní}
\label{Chapter.Implementation.BrowsingCore}

Jednotlivé implementace klientských skriptovacích enginů využívají různá rozhraní pro komunikaci s prohlížečem a dokumentem, ve kterém jsou jejich skripty vloženy. Těmito rozhraními myslíme např. rozhraní pro objekty \texttt{Window}, \texttt{Location}, \texttt{History}, \texttt{Document} aj. Aby bylo možné poskytnout implementaci pro tyto zmíněné rozhraní, bylo nutné implementovat jednoduché jádro pro procházení HTML stránek.

V této kapitole se budeme zabývat obecným jádrem pro procházení HTML stránek. Jelikož současná implementace probíhala primárně pro JavaScriptový engine, popíšeme také korespondující rozhraní, která jsou viditelná v klientském JavaScriptu. Jednotlivá implementovaná rozhraní se snaží v maximální možné míře využívat fundamentální koncept jádra prohlížeče. Samotné jádro je s těmito rozhraními provázáno jen minimálně.

V kapitole \ref{Chapter.Implementation.BasicConcepts} nejprve definujeme základní pohled na prohlížeč jako na prohlížecí jednotky kontextu. Kapitola \ref{Chapter.Implementation.EventLoop} pojednává o událostní smyčce, která zapouzdřuje všechny úlohy prohlížeče. Navigace dokumentů a jeho navracení procházením historie je popsáno v kapitolách \ref{Chapter.Implementation.DocumentNavigation} a \ref{Chapter.Implementation.TraversingHistory}. Následující kapitoly dokončují výklad a přidávají další rozhraní, která jsou viditelná z klientského JavaScriptu. 

\subsection{Základní koncepty prohlížeče}
\label{Chapter.Implementation.BasicConcepts}

Prohlížečem budeme od této chvíle rozumět uživatelského agenta, angl. user agent, ať již bude, nebo nebude sloužit k prohlížení webu. Tento pojem bude reprezentovat instanci celého funkčního jádra, které umožňuje navigování HTML dokumentů a jiných zdrojů.

V implementaci představuje uživatelského agenta třída \texttt{UserAgent}, která shromažďuje nastavení a umožňuje jednotný přístup ke sdíleným datům. Hlavní funkcí uživatelského agenta, je umožnění otevírání a zavírání procházecích jednotek \texttt{BrowsingUnit}, neboli jednotek, které zapouzdřují kontext na nejvyšší úrovni (okno, prohlížecí panel) pro zobrazování dokumentu. 

Procházecí jednotky (\ref{Figure.UserAgentAndBrowsingUnit}) v sobě obsahují hlavní procházecí kontext \texttt{BrowsingContext}, který je reprezentován na této úrovni vždy třídou \texttt{WindowBrowsingContext}. Uvnitř jednotek je dále uchovávána reference na událostní smyčku (kapitola \ref{Chapter.Implementation.EventLoop}), historii procházení (kapitola \ref{Chapter.Implementation.TraversingHistory}) a zásobník právě prováděných skriptů (kapitola \ref{Chapter.Implementation.ScriptInterface}), které jsou společné pro všechny obsažené procházecí kontexty. Všechny výše zmíněné objekty jsou vytvářeny v rámci konstrukce procházecí jednotky.

\begin{figure}[H]
  \begin{center}
    \scalebox{0.60}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-browser-UserAgent.pdf}
    }
    \caption{Diagram tříd procházecí jednotky vytvářené uživatelským agentem}
    \label{Figure.UserAgentAndBrowsingUnit}
  \end{center}
\end{figure}

Výše jsme zmínili, že procházecí jednotka vytváří procházecí kontexty. Tímto kontextem rozumíme prostředí, ve kterém jsou prezentovány dokumenty uživateli. Během navigování stránek dochází ke změně dokumentů, nikoliv však procházecího kontextu, který je po celou životnost např. okna neměnný. Procházecí kontexty poskytují jakýsi obal nad navigovanými dokumenty a informují o právě aktivním dokumentu.

Procházecí kontexty mohou být různě hierarchicky stromově zanořeny. Kořen stromu je umístěn vždy v procházecí jednotce, pokud zanedbáme pomocné procházecí kontexty \texttt{AuxiliaryBrowsingContext}. Zanoření vzniká zejména díky procházecím kontextům vytvořených přes \texttt{<iframe>} značky, které mohou obsahovat zanořené dokumenty.

Pokud je uživatelským agentem agent, který obsahuje uživatelské prostředí, tak má procházecí kontext velmi blízké provázání právě na toto uživatelské prostředí, ve kterém je zobrazován dokument. Proto byl kontext zvolen i pro definici rozhraní umožňujícího základní přístup k uživatelskému rozhraní z klientských skriptů. V kontextu se nachází rozhraní například pro navigační pole, statusový panel, posuvníky aj. Podle HTML 5 jsou tato uživatelská rozhraní viditelná skrze BarProp rozhraní . Abychom odstínili vytváření nových „schopnějších“ procházecích kontextů při každé potřebě na změnu uživatelského rozhraní, je možné tato rozhraní nastavovat v obecných a již implementovaných procházecích kontextech pomocí odpovídajících setterů. Jelikož základní uživatelský agent \texttt{UserAgent} žádné uživatelské prostředí nedefinuje, základní implementace procházecích kontextů neposkytuje ani kompletní implementaci BarProp rozhraní. Implementace je provedena pouze formou nekompletních metod, známých angl. pod pojmem stubs, který budeme od této chvíle v textu dále používat.

Abstraktní třídu pro všechny procházecí kontexty představuje třída \texttt{BrowsingContext} (obrázek \ref{Figure.BrowsingContext}), která obsahuje metody pro vytváření a hierarchickou strukturalizaci procházecích kontextů a ostatní funkcionalitu společnou pro všechny specifické kontexty. Třída vlastní referenci na historii sezení (kapitola \ref{Chapter.Implementation.TraversingHistory}), navigační kontroler (kapitola \ref{Chapter.Implementation.DocumentNavigation}) a objekt \texttt{WindowProxy} (kapitola \ref{Chapter.Implementation.WindowInterface}).

\begin{figure}[H]
  \begin{center}
    \scalebox{0.70}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-browser-BrowsingContext.pdf}
    }
    \caption{Diagram tříd procházecího kontextu}
    \label{Figure.BrowsingContext}
  \end{center}
\end{figure}

\noindent Nejdůležitějšími atributy třídy \texttt{BrowsingContext} jsou:

\begin{itemize}
  \item \textbf{\texttt{creatorDocument}} -- reference na dokument, který vytvořil procházecí kontext;
  \item \textbf{\texttt{container}} -- element, v rámci něhož byl vytvořen procházecí kontext;
  \item \textbf{\texttt{name}} -- jméno procházecího kontextu.
\end{itemize}

Všechny specifické implementované procházecí kontexty jsou znázorněny na obrázku \ref{Figure.BrowsingContextsHierarchy}.

\begin{figure}[H]
  \begin{center}
    \scalebox{0.50}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-browser-ContextsHierarchy.pdf}
    }
    \caption{Diagram tříd hierarchie procházecích kontextů}
    \label{Figure.BrowsingContextsHierarchy}
  \end{center}
\end{figure}

Z třídy kontextu dědí další abstraktní třída \texttt{IFrameContainerBrowsingContext}, která je určena pro všechny procházecí kontexty, jenž mohou vytvářet zanořené procházecí přes značky \texttt{<iframe>}. Další třídy \texttt{WindowBrowsingContext} a \texttt{IFrameBrowsingContext} reprezentují již konkrétní procházecí kontexty. Třída \texttt{WindowBrowsingContext} představuje kontext na nejvyšší úrovni -- tedy na úrovni okna. Druhá třída \texttt{IFrameBrowsingContext} pak plní funkci vnořeného kontextu vytvářeného uvnitř \texttt{IFrameContainerBrowsingContext} přes značku \texttt{<iframe>}. Pomocný kontext \texttt{AuxiliaryBrowsingContext} je dalším kontextem na nejvyšší s tím rozdílem, že není vytvářen procházecí jednotkou jako u kontextu okna. Kontext je naopak vytvářen libovolným specifickým kontextem, který potřebuje otevřít nové okno, vznikajícím např. navigací cíle \_blank.

V průběhu implementace se naskytla potřeba pro získávání notifikací z procházecích kontextů při výskytu určité události, a tak byl implementován jednoduchý observer mechanismus nad procházecími kontexty. Procházecí kontext \texttt{BrowsingContext} může vyvolat události:

\begin{itemize}
  \item \textbf{\texttt{INSERTED}} -- po vložení nového zanořeného kontextu do daného kontextu;
  \item \textbf{\texttt{REMOVED}} -- při smazání vnořeného kontext z daného kontextu;
  \item \textbf{\texttt{DESTROYED}} -- pokud je daný kontext zrušen. 
\end{itemize}

\subsection{Událostní smyčka}
\label{Chapter.Implementation.EventLoop}

Abychom mohli pokračovat ve výkladu, je zapotřebí se seznámit s událostní smyčkou, která obsluhuje úlohy uživatelského agenta. Událostní smyčka umožňuje úlohy dle potřeby mazat, různě filtrovat nebo je oddělit podle jejich typu -- zdroje úlohy. Smyčka dále sjednocuje přístup k API uživatelského agenta v jednom vlákně, aby nedocházelo k race condition a ulehčilo se řešení výlučných sekcí. Asynchronní žádosti na API, jako je např. navigování stránek nebo procházení historie, v určitém čase vždy zajistí vložení nové úlohy do událostní smyčky.

V implementaci je událostní smyčka reprezentována třídou EventLoop a je vytvářena procházecí jednotkou v rámci její konstrukce. Zjednodušený diagram tříd znázorňující funkci událostní smyčky lze vidět na následujícím obrázku \ref{Figure.EventLoop}. 

\begin{figure}[H]
  \begin{center}
    \scalebox{0.78}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-events-EventLoop.pdf}
    }
    \caption{Diagram tříd znázorňující událostní smyčku}
    \label{Figure.EventLoop}
  \end{center}
\end{figure}

Nejdůležitější metoda smyčky je queueTask(), která vkládá nové úlohy Task do front úloh TaskQueues v závislosti na tom, o jakou frontu se jedná. Rozlišení front je docíleno zdrojem úlohy TaskSource. Vkládání úloh a její vybírání zprostředkovává plánovač TaskQueuesScheduler.
 
Kromě operace na vkládání obsahuje událostní smyčka různé variace metod na filtraci a mazání úloh. Tyto metody jsou nazvány s prefixy filter a remove. Při konstrukci smyčky se vytváří nové vlákno, které čeká, dokud není naplánována nová úloha plánovačem úloh. Obecně platí, že událostní smyčka je vláknově bezpečná. Pokud si přejeme pozdržet vlákno, které vložilo úlohu do front úloh, lze toho docílit metodou queueTaskAndWait(), která interně volá metodu join() nad danou úlohou. Pokud bychom použili metodu queueTaskAndWait() přímo z vykonávacího vlákna smyčky, došlo by k jeho zablokování. Proto je zapotřebí využít jiných technik, např. zavolání metody spin() poté, co je vložena nová úloha.

Metoda spin() a její variace s prefixem spin zajišťují rotaci událostní smyčky. Rotací rozumíme přerušení aktuálně prováděné úlohy a její opětovné vložení, přičemž vložení může být různě zpožděno. Základní metoda na rotaci spin() vkládá úlohu ihned do front úloh, zatímco metoda spinForCondition() čeká na splnění určité podmínky. Podmínky jsou implementovány rozhraním Runnable, jehož metoda run() je při žádosti na odložené vložení zavolána ve speciálním vlákně. Po skončení vlákna dojde teprve ke vložení úlohy do front úloh. Přerušení právě probíhající úlohy je zajištěno vyhozením výjimky TaskAbortedException, která pokud není nikde odchycena, je propagována až do událostní smyčky. Smyčka po zachycení dané výjimky začne považovat právě vykonávající úlohu jako za dokončenou. Úloha, která je vložena rotací smyčky do front úloh, je kopií staré úlohy ovšem s novým vykonávacím tělem, jež je předáváno jako actionAfter parametr do metod pro rotace. Využití rotací událostní smyčky lze využít např. během posouvání na fragment stránky, přičemž stránka není ještě stále kompletní. V tomto případě lze rotací zapříčinit čekání na daný fragment a poté, co je vložen do dokumentu, vložit úlohu, která zajistí posunutí na daný fragment.

Jak víme, každá úloha musí rozšiřovat abstraktní třídu Task. Úloha musí být dále také asociována s dokumentem a musí nést zdroj, podle kterého se rozhoduje, do jaké fronty se má úloha zařadit. Položka dokumentu v úloze velmi často slouží k určení cíle úlohy, čehož se využívá při odstraňování úloh pro dokumenty, které vystoupily z procházecího kontextu, např. pokud došlo k navigaci na jiný dokument. 

Fronty úloh TaskQueues jsou rozšířením hašovací tabulky, která mapuje zdroje úloh na fronty přiřazené tomuto zdroji. Třída TaskQueues přidává nové metody pro intuitivnější práci s frontami úloh -- metody pro vyhledávání úloh ve frontách, jejich filtraci a odstraňování.

Cílem plánovače úloh TaskQueuesScheduler bylo zajistit oddělené plánování úloh od událostní smyčky a umožnit v budoucnu různé implementace plánování. Tak jako událostní smyčka, má plánovač vlastní vlákno pro plánování. Přes své rozhraní přijímá nové úlohy, které vkládá do front úloh. Ve vlastním vykonávacím vlákně tyto úlohy podle plánovacího algoritmu vybírá a vkládá je do fronty naplánovaných úloh. V současnosti jediná implementace plánovače úloh RoundRobinScheduler zajišťuje rotační odebírání úloh z front úloh, přičemž pokud je některý zdroj úlohy neaktivní a jeho fronta je prázdná, je po určitém časovém kvantu vnitřním časovačem odstraněn z pole pro rotaci.

\subsection{Stahování zdrojů}
\label{Chapter.Implementation.DownloadingResources}

Předtím než přejdeme k popisu dokumentu a jeho parsování, popíšeme v následující kapitole, jak je řešeno jeho stažení. Stahování bylo řešeno obecně pro různé typy komunikačních protokolů a pro různé typy formátů obsahu. Jelikož lze stahovat různé druhy obsahu, nikoliv pouze dokumenty, budeme se v této kapitole bavit pouze o zdrojích. Pokud není obsahem zdroje přímo dokument, jsou obsahy často zpracovávány a do dokumentu dodatečně vkládány. Zpracovávání obsahu zdrojů popíšeme blíže v následující kapitole \ref{Chapter.Implementation.ContentHandling}.

Základní třídou pro všechny zdroje je v implementaci třída Resource (viz obrázek \ref{Figure.Resource}). Třída poskytuje vstupní datový tok obsahu zdroje, nese základní informace o tom, z jaké adresy byl zdroj získán a typu jeho obsahu. Informuje, zda zdroj je dostupný nebo jestli by mělo být provedeno přesměrování. Pokud je zdroj získáván pomocí URLConnection rozhraní, existuje v implementaci bližší reprezentace pro tyto zdroje -- abstraktní třída URLConnectionResource. Byly implementovány celkem 4 druhy konkrétních zdrojů: HttpResource, HttpsResource, FileResource a JavaScriptResource. V současné době lze tedy stahovat zdroje z URL adres, jež nesou protokoly file, http, https a javascript.

\begin{figure}[H]
  \begin{center}
    \scalebox{0.65}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-resource-Resource.pdf}
    }
    \caption{Diagram tříd znázorňující abstraktní třídu pro všechny zdroje}
    \label{Figure.Resource}
  \end{center}
\end{figure}

Pokud hovoříme o stažení zdroje, máme na mysli navázání připojení a podle daného protokolu komunikaci se serverem. Komunikaci se serverem a vytváření konkrétního zdroje zajišťují třídy ovladačů -- třídy rozšiřující abstraktní třídu pro ovladače FetchHandler. Každý konkrétní ovladač vytváří jeden z výše zmíněných specifických zdrojů (viz obrázek \ref{Figure.FetchRegistry}). Pro stažení zdroje je určena metoda fetch(), která vnitřně volá chráněnou metodu fetchImpl(). Pokud byl ovladač vytvořen v synchronním módu, pak tato operace způsobí blokování do doby stažení zdroje. Pro získání staženého zdroje slouží metoda getResource(), která také volá chráněnou metodu, tentokrát getResourceImpl(). 

\begin{figure}[H]
  \begin{center}
    \scalebox{0.80}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-resource-FetchRegistry.pdf}
    }
    \caption{Diagram tříd znázorňující registr ovladačů}
    \label{Figure.FetchRegistry}
  \end{center}
\end{figure}

V praxi při získávání zdroje máme k dispozici pouze jeho URL. Nevíme předem, jaký ovladač pro jeho stažení použít. Přesto bychom chtěli mít jednotné rozhraní, které by převzalo předanou URL a vyhodnotilo, zda je zdroj stažitelný, popř. ho i stáhlo. Za tímto účelem vznikl registr všech ovladačů FetchRegistry, který shromažďuje všechny podporované ovladače a umožňuje nad nimi vyhledávat podle protokolu předané URL. Registr registruje třídy ovladačů a vytváří na ně asociace v závislosti na tom, jaké protokoly podporují. Podporované protokoly jsou získávány ze speciální anotace třídy FetchHandlerPreamble, která musí být přítomna u každé třídy registrovaného ovladače.

\subsection{Zpracovávání obsahu zdrojů}
\label{Chapter.Implementation.ContentHandling}

V předešlé kapitole \ref{Chapter.Implementation.DownloadingResources} bylo popsáno, jak lze získávat zdroje. Zdroje musí být
ovšem dále zpracovávány v závislosti na typu obsahu, který představují, převedeny na dokument a až poté mohou být zobrazeny. Pro zpracovávání byla zvolena podobná návrhová myšlenka jako pro získávání zdrojů. Byl implementován registr továren ovladačů ContentHandlerRegistry, který spravuje továrny ovladačů pro různé typy obsahů a získává instance ovladačů v závislosti na požadovaném MIME typu obsahu.

\begin{figure}[H]
  \begin{center}
    \scalebox{0.80}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-resource-ContentHandlerRegistry.pdf}
    }
    \caption{Diagram tříd znázorňující registr továren ovladačů}
    \label{Figure.ContentHandlerRegistry}
  \end{center}
\end{figure}

Třída ovladače, která zajišťuje zpracovávání daného typu obsahu, musí být konkrétní třídou nad abstraktní třídou ContentHandler. Pro zpracování obsahu se volá metoda perform (), která přijímá zdroj ke zpracování. V současné době je implementován pouze jeden ovladač -- na zpracovávání HTML dokumentů HtmlDocumentHandler, který vkládá do událostní smyčky úlohu, jež zajišťuje tvorbu dokumentu, přidání nového dokumentu do historie, její aktualizaci a v poslední řadě zahájení parsování dokumentu. V implementaci jsou také připraveny návrhy tříd ovladačů na zpracovávání obrázků, textových souborů, XML dokumentů, médií, aj.

Z důvodu potřeby podobné funkčnosti v jiné části implementace -- výběru skriptovacího enginu v závislosti na MIME typu skriptu (viz kapitola \ref{Chapter.Implementation.ScriptEngines}) byly implementovány generické třídy pro správu továren objektů jakéhokoliv typu. Abstraktní továrna, která obsluhuje získávání obsahů podporovaného MIME typu, je v implementaci nazvána MimeContentFactoryBase. Každá konkrétní továrna redefinuje metodu pro vytváření obsahu getContent() a metody pro zjištění podporovaných MIME typů. Rozlišujeme dva druhy MIME typů:

\begin{itemize}
  \item \textbf{explicitně podporované} -- typy, které předem můžeme určit, a o kterých víme, že továrna bude tyto typy podporovat, tzn. známe celou jejich podobu, např. text/html; Pro zjištění těchto typů slouží metoda getExplicitlySupportedMimeTypes();
  \item \textbf{implicitně podporované} -- typy, kde rozhodne o jejich platnosti až jejich formát, částečná shoda, např. pouze prefix text/; Pro test, zda se jedná o implicitně podporovaný typ je vyčleněná metoda isImplicitlySupported().
\end{itemize}

\subsection{Navigace mezi dokumenty}
\label{Chapter.Implementation.DocumentNavigation}

V kapitole \ref{Chapter.Implementation.DownloadingResources} byla popsána metodika, jak se získávají zdroje, jež lze využít nejenom pro stahování dokumentů, ale i pro získávání souborů kaskádových stylů nebo externích skriptů během načítání stránky. Předchozí kapitola \ref{Chapter.Implementation.ContentHandling} se zabývala výhradně zpracováním obsahu zdroje, vytvářením dokumentu a jeho zobrazením. Celý proces, který zahrnuje stažení zdroje a následné zobrazení dokumentu, přičemž je změněn předchozí aktivní dokument, lze nazvat navigací mezi dokumenty.

Požadavky na navigování nového dokumentu mohou přicházet asynchronně. V implementaci je vstupním bodem pro příchod nových požadavků navigační kontroler -- třída NavigationController. Kontroler všechny požadavky registruje a pokouší se je obsloužit. Obsluha požadavků je delegována třídě požadavku NavigationAttempt, která o stavu zpracování požadavku informuje svůj kontroler pomocí callback metod rozhraní NavigationAttemptCallback. Callback metody informují o následujících stavech:

\begin{itemize}
  \item \textbf{vyzrání} -- navigovaný dokument byl přidán do historie, ale stále není kompletní;
  \item \textbf{zrušení} -- navigace byla zrušena uživatelem nebo kvůli nějaké chybě;
  \item \textbf{dokončení} -- navigace byla kompletně provedena; 
  \item \textbf{výběru cílového procházecího kontextu} -- byl zvolen procházecí kontext, ve kterém bude navigace prováděna.
\end{itemize}

Navigace přechází do jednotlivých stavů zavoláním korespondujících metod navigace: complete(), cancel() nebo mature(). V závislosti na tom, jaká callback metoda byla navigačním požadavkem zavolána, je v navigačním kontroleru provedena k tomu odpovídající akce. Při výběru cílového kontextu je požadavek zaregistrován v kontroleru, naopak při zrušení nebo dokončení požadavku je požadavek zcela odregistrován. Jelikož bylo žádoucí informovat o stavech provádění požadavků uvnitř navigačního kontroleru i vnější okolí, byl vytvořen opět jednoduchý observer nad navigačním kontrolerem. Události, které mohou být vyvolány, kopírují metody callback volání z navigačního požadavku. 

\begin{figure}[H]
  \begin{center}
    \scalebox{0.75}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-navigation-NavigationController.pdf}
    }
    \caption{Diagram tříd znázorňující navigační kontroler}
    \label{Figure.NavigationController}
  \end{center}
\end{figure}

Navigační kontroler vytváří celkem dva typy navigací. Prvním typem navigace je navigace NewNavigationAttempt, která vzniká po zavolání metody navigate() a která přidává do historie nový navigovaný dokument. Druhý typ navigace UpdateNavigationAttempt vznikající zavoláním metody update() přepíše dokument předaného záznamu historie, který je tímto aktualizován.

\noindent K vytvoření navigačního požadavku je zapotřebí nastavit:  

\begin{itemize}
  \item \textbf{\texttt{navigationController}} -- navigační kontroler, který vlastní tento požadavek;
  \item \textbf{\texttt{sourceBrowsingContext}} -- vybraný cílový procházecí kontext, kde bude navigován nový zdroj;
  \item \textbf{\texttt{url}} -- pokud je daný kontext zrušen. 
  \item \textbf{\texttt{exceptionEnabled}} -- nastaveno pokud se mají generovat DOM výjimky;
  \item \textbf{\texttt{explicitSelfNavigationOverride}} -- když je nastaveno, bude cílovým procházecím kontextem zvolen procházecí kontext navigačního kontroleru a nebude se vyhodnocovat efektivní procházecí kontext;
  \item \textbf{\texttt{replacementEnabled}} -- nastaveno pokud žádáme, aby byl přepsán právě aktivní záznam historie a smazány všechny jeho následující záznamy.
\end{itemize}

Pro vykonání a spuštění navigačního algoritmu je vyčleněná metoda perform(). Algoritmus provádí zjednodušeně následující body:

\begin{itemize}
  \item \textbf{bezpečnostní kontroly} -- testuje se, zda můžeme navigovat vybraný cílový procházecí kontext;
  \item \textbf{výběr efektivního cílového procházecího kontextu} -- pokud není navigace prováděna v procházecím kontextu \texttt{<iframe>} se seamless atributem elementu, pak je efektivní cílový kontext vždy totožný s vybraným cílovým procházecícm kontextem;
  \item \textbf{navigace na fragment dokumentu} -- když navigujeme pouze fragment dokumentu, pak se provede okamžitá navigace na pozici fragmentu, aktualizuje se historie a tímto bodem navigace ihned končí; 
  \item \textbf{uvolnění aktivního dokumentu} -- aktivní dokument cílového procházecího kontextu je uvolněn;
  \item \textbf{získání ovladače na stažení zdroje} -- při úspěchu přechází navigační požadavek do asynchronního zpracovávání;
  \item \textbf{přesměrování} -- když je zapotřebí přesměrovat na jiný zdroj;
  \item \textbf{získání ovladače na zpracování zdroje} -- vyhledání ovladače v registru ovladačů ContentHandlerRegistry; 
  \item \textbf{zpracování zdroje} -- zavolání metody perform() nad vyhledaným ovladačem.
\end{itemize}

Výše popsané třídy navigování se týkaly jádra uživatelského agenta. Navigovat dokumenty je ovšem přístupné i z klientského JavaScriptu. Pro tento účel slouží rozhraní Location, které bylo také zcela implementováno (obrázek \ref{Figure.Location}). Každý dokument procházecího kontextu vlastní unikátní instanci tohoto rozhraní.
 
\begin{figure}[H]
  \begin{center}
    \scalebox{0.65}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-navigation-Location.pdf}
    }
    \caption{Diagram tříd znázorňující rozhraní Location}
    \label{Figure.Location}
  \end{center}
\end{figure}
 
Pro implementaci bylo využito navigačního kontroleru. Metody assign() a reload() volají metodu kontroleru navigate() s nastaveným příznakem replacementEnabled. Metoda assign() naviguje nový dokument bez přepsání právě aktivního dokumentu, příznak replacementEnabled není nastaven. Všechny metody nastavují příznak exceptionEnabled, takže jsou navigačním požadavkem generovány bezpečnostní výjimky.

\subsection{Procházení historie}
\label{Chapter.Implementation.TraversingHistory}

Během navigování stránek dochází ke změně aktivních dokumentů. Všechny předchozí navigované dokumenty jsou nadále uchovávány v historii sezení. Průchodem historie sezení jde kdykoliv navracet dokumenty, které nejsou momentálně aktivní v současném procházecím kontextu. Historie sezení se vytváří v rámci konstrukce procházecího kontextu, jenž danou historii vlastní. Historii sezení si lze představit jako pole všech někdy navigovaných dokumentů, s ukazatelem na aktivní záznam vlastnící aktivní dokument procházecího kontextu (obrázek \ref{Figure.SessionHistory}).

\begin{figure}[H]
  \begin{center}
    \scalebox{0.50}{
      \includegraphics{fig/history.pdf}
    }
    \caption{Vizualizace historie sezení se záznamy mezi kterými lze posouvat}
    \label{Figure.SessionHistory}
  \end{center}
\end{figure}

V implementaci je historie sezení představována třídou SessionHistory (obrázek \ref{Figure.SessionHistoryDiagram}). Je implementována jako lineární list záznamů historie SessionHistoryEntry. Záznam historie musí minimálně uchovávat adresu zdroje, odkud byl dokument získán. Dále by měl záznam obsahovat dokument, který byl vytvořen během navigace, která vytvořila tento záznam. A dodatečně může záznam uchovávat titulek a datum navštívení stránky, stavový objekt StateObject a uživatelský kontext UserPersistedState. Stavovým objektem rozumíme objekty, které lze v historii uchovávat přes rozhraní History, popsané níže. Uživatelským kontextem rozumíme např. pozice posuvníků před přesunutím na jiný záznam historie a jiné nastavení specifické pro danou HTML stránku. 

\begin{figure}[H]
  \begin{center}
    \scalebox{0.77}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-history-SessionHistory.pdf}
    }
    \caption{Diagram tříd znázorňující historii sezení}
    \label{Figure.SessionHistoryDiagram}
  \end{center}
\end{figure}

Tak jako u procházecích kontextů a navigačního kontroleru, implementuje objekt historie sezení jednoduchý observer mechanismus. Typy událostí generované historií sezení jsou:

\begin{itemize}
  \item \textbf{\texttt{TRAVERSED}} -- událost generovaná po dokončení přechodu z jednoho záznamu historie na nový záznam historie;
  \item \textbf{\texttt{INSERTED}} -- vložení nového záznamu na konec listu historie sezení;
  \item \textbf{\texttt{CURRENT\_CHANGED}} -- pokud byl nastaven nový aktuální záznam historie. Událost zároveň značí, že došlo ke změně aktivního dokumentu procházecího kontextu, který vlastní dané historie sezení; 
  \item \textbf{\texttt{REMOVED}} -- smazání záznamu z historie sezení;
  \item \textbf{\texttt{DESTROYED}} -- zrušení historie sezení.
\end{itemize}

Třída sezení historie SessionHistory obsahuje metody pro přidávání záznamů historie, jejich odebírání, filtrování a nastavování aktivního záznamu. Celý proces průchodu historií a změny aktivního záznamu na jiný záznam historie je obsáhlejší proces, který zahrnuje více kroků. Průchod historií sezení je implementován metodou traverseHistory(), která bere jako parametr záznam sezení historie, který by měl být zvolen jako aktivní. Během průchodu historií se zjednodušeně provádí následující kroky:

\begin{enumerate}
  \item Zjištění, zda navigovaný záznam obsahuje objekt dokumentu. Pokud není dokument obsažen a my si přejeme posunout na tuto pozici v historii, musí se dokument obnovit zavoláním metody update() daného navigačního kontroleru.
  \item Aktualizace uživatelského kontextu -- uchování např. pozic posuvníků.
  \item Odstranění všech úloh, které by byly po průchodu historií neplatné.
  \item Nastavení nového aktivního záznamu historie sezení.
  \item Generování události load, pokud je dokument kompletní.
  \item Smazání všech záznamů před aktivním záznamem, pokud je to požadováno.
  \item Aktualizace uživatelského prostředí z uchovaného uživatelského kontextu.
  \item Kontrola, zda se změnil v URL fragment nebo stavový objekt a generování patřičných událostí hashchange nebo popstate.
\end{enumerate}

Pro zpřístupnění procházení historie z kódu klientského JavaScriptu bylo nutné implementovat rozhraní History. K implementaci požadovaného rozhraní bylo zapotřebí sjednotit všechny historie sezení všech procházecích kontextů procházecí jednotky. Rozhraní History totiž poskytuje procházení všech dokumentů, které kdy byly navigovány v procházecí jednotce. Spojení všech záznamů historií sezení dané procházecí jednotky proběhlo na základě času jednotlivých záznamů, kdy byly tyto záznamy vytvořeny, neboli kdy byly dokumenty záznamů navigovány. Aktuální záznam společné historie je vždy určen podle posledně vybraného záznamu během průchodu historií sezení v některém procházecím kontextu procházecí jednotky. Tvorba společné historie sezení je znázorněna na obrázku XY, kde čísla záznamu reprezentují unikátní čísla generovaná v čase, kdy byl záznam vytvořen. Posledně vybraný záznam je záznam s číslem 4.

\begin{figure}[H]
  \begin{center}
    \scalebox{0.40}{
      \includegraphics{fig/joint-history.pdf}
    }
    \caption{Vizualizace vytvoření sjednocené historie sezení}
    \label{Figure.SessionHistory}
  \end{center}
\end{figure}

Sjednocenou historii sezení vlastní procházecí jednotka. V implementaci je představována třídou JointSessionHistory. Třída vnitřně registruje BrowsingContextListener a SessionHistoryListener nad všemi procházecími kontexty a historiemi sezení procházecí jednotky. Nasloucháním odpovídajících událostí získává neustálé informace o změnách historie, čímž se může sama sebe aktualizovat -- vytvářet sjednocenou historii. Reference na implementaci rozhraní History, jež zpřístupňuje sjednocenou historii z kódu JavaScriptu, se nachází v dokumentu. Kromě procházení společné historie sezení, rozhraní History umožňuje uchovávat stavový objekt state. Nový stavový objekt můžeme uložit pomocí speciální metody pushState(), která daný objekt nastavuje v aktuálním záznamu historie sezení. Když procházíme historií, je tento stavový objekt vždy z vybraného záznamu historie přečten a nastaven do atributu state rozhraní History.

\begin{figure}[H]
  \begin{center}
    \scalebox{0.75}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-history-History.pdf}
    }
    \caption{Diagram tříd znázorňující rozhraní History}
    \label{Figure.History}
  \end{center}
\end{figure}

\subsection{Dokument a jeho parsování}
\label{Chapter.Implementation.DocumentParsing}

Ačkoliv implementace rozhraní dokumentu viditelného z klientského JavaScriptu nebyla cílem této práce, bylo zapotřebí implementovat jeho vnitřní reprezentaci v kontextu jádra uživatelského agenta. V dokumentu jsou totiž uchovávány reference na implementovaná rozhraní Window, Location a History. Zároveň bylo nutno v dokumentu definovat vytváření elementů \texttt{<iframe>} a \texttt{<script>} tak, aby jejich implementace odpovídala specifikaci HTML 5. Třída, která reprezentuje implementaci dokumentu je nazvána Html5DocumentImpl a znázorněna na obrázku XY. 

\begin{figure}[H]
  \begin{center}
    \scalebox{0.75}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-dom-Html5DocumentImpl.pdf}
    }
    \caption{Diagram tříd znázorňující třídu dokumentu}
    \label{Figure.DocumentImpl}
  \end{center}
\end{figure}

Dokument dědí z HTMLDocumentImpl a může být asociován s procházecím kontextem nebo parserem, který daný dokument vytvořil. Všechny procházené dokumenty musí mít vždy přidělený procházecí kontext. Zatímco dokument, který byl vytvořen zavoláním metody createDocument() v rámci provádění skriptu, žádnou referenci na procházecí kontext nevlastní. Stav dokumentu, ve kterých se může nacházet, je dán atributem výčtu DocumentReadyState:

\begin{itemize}
  \item \textbf{\texttt{LOADING}} -- dokument je načítán parserem;
  \item \textbf{\texttt{INTERACTIVE}} -- parser dokončil dokument, ale stále se čeká na některé zdroje;
  \item \textbf{\texttt{COMPLETE}} -- dokument je zcela kompletně načten.
\end{itemize}

V dokumentu byly implementovány základní sandbox aspekty. Akce, které sandbox omezuje pro daný dokument, jsou uvedeny množinou sandbox přepínačů SandboxingFlag. 

Během navigace nového dokumentu, jsou nové dokumenty vytvářeny v rámci zpracovávání obsahu zdroje (kap. XY), konkrétně zavoláním statické metody createDocument() nad dokumentem. Během konstrukce dokumentu vznikají nové instance rozhraní Location a History, které dokument nadále drží ve svém vlastnictví. Pokud byla metoda createDocument() zavolána s recyklovaným dokumentem recycleDocument, je pro nastavení reference Window objektu využit Window objekt recyklovaného dokumentu. Když není recyklovaný dokument nastaven, v rámci konstrukce se vytváří zcela nová instance Window objektu. Jakmile je nový dokument vytvořen, následuje jeho předání parseru, který zajistí jeho kompletní načtení.

Implementaci parseru dokumentu představuje třída ScriptableDocumentParser (obrázek XY). Parsování se vyvolá zavoláním metody parse(), které se předá referenční objekt dokumentu a vstupní stream s dokumentem. Instance dokumentu není vytvářena parserem, dokument je pouze parserem sestavován a nikoliv instanciován. Třída ScriptableDocumentParser reprezentuje vnější rozhraní pro komunikaci s parserem, přičemž parsování neimplementuje. Oddělení od parseru bylo zvoleno z důvodu případné budoucí změny parseru dokumentů na některý jiný, který by více vyhovoval specifikům HTML5. V současnosti je parsování zajištěno modifikovaným NekoHTML parserem ScriptDOMParser, který přidává podporu pro vytváření vnořených procházecích kontextů pro \texttt{<iframe>} elementy a spuštění skriptů v rámci parsování dokumentu, jak to vyplývá z HTML5 specifikace. 

\begin{figure}[H]
  \begin{center}
    \scalebox{0.75}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-parser-Html5DocumentParser.pdf}
    }
    \caption{Diagram tříd znázorňující třídu parseru dokumentu}
    \label{Figure.DocumentParser}
  \end{center}
\end{figure}

Podle specifikace by měl být parser inkrementální a reentrantní. Měla by být též implementována možnost jeho pozastavení, kde by byl kontext vrácen událostní smyčce na zpracování některé jiné úlohy. Pozastavení parseru je potřeba např. při dokončení parsování skriptu, který by měl být spuštěn v pořadí , a při blokování jiným nevykonaným skriptem. Skript může způsobit blokování dalšího skriptu, pokud nebyl stále spuštěn, např. z důvodu, že nebyl dosud stažen ze zdroje. V této situaci musíme parser pozastavit a počkat do té doby, dokud není zcela vykonán skript, který byl v pořadí před právě zpracovaným skriptem. Pozastavení parseru by se obvykle řešilo rotací událostní smyčky. Z důvodu nemožnosti rekonstrukce zásobníku volání NekoHTML parseru bylo pozastavení řešeno vyčleněním parseru do vlastního vlákna a jeho uspáním.

Třída Html5DocumentParser v současnosti uchovává referenci na skript, který bude blokovat parsování dokumentu, pokud bude zapotřebí spustit některý další skript v pořadí. V třídě jsou také listy skriptů:

\begin{itemize}
  \item \textbf{\texttt{onFinishScripts}} -- skripty, které se mají spustit po dokončení parsování;
  \item \textbf{\texttt{inOrderASAPScripts}} -- skripty k okamžitému spuštění jakmile budou dostupné ve správném pořadí, tak jak byly umístěny v DOM;
  \item \textbf{\texttt{asapScripts}} -- skripty k okamžitému spuštění jakmile budou dostupné. 
\end{itemize}

Když parser ScriptDOMParser dokončí parsování dokumentu, je třídou Html5DocumentParser vložena do událostní fronty úloha TheEndTask, čímž se navrátí řízení z asynchronního parsování opět událostní smyčce. Úloha nastaví stav dokumentu na INTERACTIVE, vykoná všechny skripty z listu onFihishScripts, vyvolá událost DOMContentLoaded nad parsovaným dokumentem a čeká, dokud nejsou vyprázdněny zbývající listy se skripty -- inOrderASAPScripts a asapScripts. Po vykonání všech skriptů dojde k nastavení stavu dokumentu na COMPLETE a vyvolání události load nad daným dokumentem. 

\subsection{Rozhraní Window}
\label{Chapter.Implementation.WindowInterface}

V kapitole XY jsme uvedli interní implementaci dokumentu, která obsahovala instance rozhraní History a Location -- viditelných rohraní z klientského JavaScriptu. Zatím jsme ovšem nedefinovali, v rámci jakého rozhraní by měly být viděny právě tyto instance. V JavaScriptu pro zpřístupnění těchto rozhraní slouží globální objekt Window.

V implementaci je objekt Window implementován třídou Window. Instance nebo reference v případě recyklace objektu Window vzniká během konstrukce dokumentu. Implementovaná množina operací a atributů, s vynecháním atributů uživatelského rozhraní, je znázorněna na obrázku XY. 

\begin{figure}[H]
  \begin{center}
    \scalebox{0.75}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-window-Window.pdf}
    }
    \caption{Diagram tříd znázorňující rozhraní Window}
    \label{Figure.WindowInterface}
  \end{center}
\end{figure}

Objekt Window využívá plně jádra uživatelského agenta, a tak jeho implementace je minimální. Atributy window, self, frames vrací WindowProxy objekt procházecího kontextu dokumentu, který tento Window objekt vlastní. Atribut parent vrací WindowProxy objekt rodičovského procházecího kontextu a atribut top WindowProxy objekt kontextu na nejvyšší úrovni. Jedná-li se o Window objekt vnořeného procházecího kontextu IFrameBrowsingContext, vrací atribut frameElement element, přes který byl tento vnořený procházecí kontext vytvořen. Když je objekt Window vlastněn pomocným procházecím kontextem AuxiliaryBrowsingContext, atribut opener vrací objekt WindowProxy procházecího kontextu, který pomocný procházecí kontext otevřel. Atributy location a history přímo vrací aktuální instanci těchto rozhraní z dokumentu, který objekt Window vlastní. Metoda close() ruší procházecí kontext asociovaného dokumentu zavoláním metody discard(). Metoda open() naviguje nové dokumenty s využitím navigačního kontroleru NavigationController procházecího kontextu objektu Window. Metoda stop() ruší všechny požadavky na navigace. Poslední metody pro zobrazení uživatelských dialogů volají korespondující metody v asociovaném procházecím kontextu. 

V objektu Window byly implementovány všechny položky rozhraní GlobalEventHandlers a WindowEventHandlers, které přidávají podporu pro snadnou registraci obslužné rutiny pouhým přiřazením callback funkce do atributu bez potřeby voláni metody addEventListner(). Objekt Window implementuje také rozhraní ObjectGetter, které slouží pro získávání objektů WindowProxy vnořených procházecích kontextů podle jejich jména nebo indexu. Indexem rozumíme pořadové číslo 0..n, kde n počet všech procházecích vnořených kontextů určený položkou length.

V předchozím textu jsme se bavili několikrát o WindowProxy objektu. Tímto objektem myslíme instanci, která má totožné chování jako aktuální globální objekt Window s tím rozdílem, že není asociována pevně s nastaveným dokumentem. Dokument objektu WindowProxy je proměnný v závislosti na tom, který je právě v daném procházecím kontextu WindowProxy objektu aktivní. 

\subsection{DOM události}
\label{Chapter.Implementation.DOMEvents}

Všechny uzly objektového modelu dokumentu by měly umožňovat generování událostí. Aby byla tato funkčnost splněna, musí uzly implementovat rozhraní EventTarget. Jelikož dokument Html5DocumentImpl dědí z třídy DocumentImpl knihovny Xerces, nebylo nutno generování událostí pro dokument řešit. Knihovna Xerces totiž rozhraní EventTarget implementuje pro všechny uzly dokumentu. V klientském JavaScriptu ovšem není kořenem DOMu samotný dokument, jak je implementováno v Xerces, nýbrž objekt Window. Z tohoto důvodu bylo zapotřebí řešit provázání s objektem Window a generování událostí i do nového kořenového objektu, jak je znázorněno na obrázku XY. 

\begin{figure}[H]
  \begin{center}
    \scalebox{0.75}{
      \includegraphics{fig/events.pdf}
    }
    \caption{Ilustrace toku události z objektu Window do objektu dokumentu}
    \label{Figure.EventWindowDocument}
  \end{center}
\end{figure}

Generování událostí probíhá zavoláním metody dispatchEvent() rozhraní EventTarget nad jakýmkoliv uzlem, který toto rozhraní implementuje. V implementaci Xerces jsou všechny události, které jsou předány metodě dispatchEvent(), dále delegovány chráněné metodě dokumentu dispatchEvent(), která požadované generování událostí implementuje. Jednotné místo v dokumentu pro generování událostí umožnilo snadnou změnu mechanismu generování událostí. Po provedené úpravě se dokument chová tak, jakoby byl kořenovým uzlem pro generování událostí Window objekt.

Během generování událostí v přizpůsobeném modelu mohou nyní nastat dvě situace. První situace je, pokud bylo zavoláno dispatchEvent() nad objektem Window. V tomto momentě se okamžitě volají všichni zaregistrovaní odběratelé dané události, přičemž fáze CAPTURE a BUBBLE se neprovádí, jelikož se jedná o kořenový uzel. Druhá situace již obnáší změnu zmíněné chráněné metody dispatchEvent(). Situace vzniká po zavolání dispatchEvent() nad některým uzlem dokumentu. V tomto případě se provádí následující kroky:

\begin{enumerate}
  \item Zavolání metody dispatchEventFromDocument() nad objektem Window, ve které se obslouží CAPTURE fáze. 
  \item Zavolání původní implementace dispatchEvent(), která zajistí propagaci události až do daného cíle a její návrat zpět do dokumentu. 
  \item Opětovné zavolání dispatchEventFromDocument(), tentokrát pro obsloužení BUBBLE fáze.
\end{enumerate}

Elementy DOMu, ale i objekt Window v klientském JavaScriptu neimplementují pouze rozhraní EventTarget, ale přidávají i vhodně pojmenované atributy, jejichž setter zajistí registraci nastavené událostní obslužné rutiny jako odběratele v daném objektu. Elementy implementují rozhraní s množinou atributů událostních obslužných rutin GlobalEventHandlers. Objekt Window implementuje dále rozhraní WindowEventHandlers.

Událostní obslužné rutiny musí v programu implementovat EventHandler, který jako rozhraní EventListener obsahuje pouze jednu metodu pro obsloužení dané události. Při nastavování obslužných rutin do korespondujících atributů událostních obslužných rutin rozhraní GlobalEventHandlers nebo WindowEventHandlers musela být řešena odregistrace odběratele staré obslužné rutiny a registrace nového odběratele nové obslužné rutiny. Za tímto účelem byla vytvořena třída EventHandlerEventListener, která automaticky registruje a odebírá událostní obslužné rutiny u některého cíle implementujícího EventTarget. (obr XY)

\begin{figure}[H]
  \begin{center}
    \scalebox{0.75}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-dom-events-EventHandlerEventListener.pdf}
    }
    \caption{Diagram tříd znázorňující implementaci registrování objektu EventHandler}
    \label{Figure.EventHandlerEventListener}
  \end{center}
\end{figure}

V současnosti jsou jádrem prohlížeče generovány události uvedené v následující tabulce XY.

\begin{table}[H]
  \begin{center} 
    \begin{tabular}{|l|p{5cm}|P{6cm}|} \hline
    \theadStart{Třída události} & \thead{Popis třídy} & \thead{Typy událostí} \\ \hline
    \texttt{Event} & jednoduché události neobsahující žádné další informace kromě názvu události & \texttt{load}, \texttt{beforescriptexecute}, \mbox{\texttt{unload}}, \texttt{afterscriptexecute}, \texttt{abort}, \texttt{DOMContentLoaded} \\ \hline
    \texttt{PopStateEvent} & událost změny uloženého stavu ve společné historii sezení & \texttt{popstate} \\ \hline
    \texttt{HashChangeEvent} & událost změny fragmentu v~URL prohlížené stránky & \texttt{hashchange} \\ \hline
    \texttt{ErrorEvent} & událost reprezentující chybu & \texttt{error} \\ \hline
    \texttt{MouseEvent} & události vyvolané ukazatelem myši & \texttt{mouseover}, \texttt{mousedown}, \texttt{mouseup}, \texttt{click}, \texttt{dblclick} \\ \hline
    \end{tabular}
    \caption{Třídy podporovaných událostí}
    \label{Table.SupportedEvents}
  \end{center}
\end{table}

\subsection{Rozhraní URLUtils a URL}
\label{Chapter.Implementation.URLUtilsInterface}

Pro zkompletování výkladu všech rozhraní, která jsou v současné implementaci viditelná z klientského JavaScriptu nám chybí uvést poslední rozhraní URL, jež čerpá z dalšího rozhraní URLUtils. Rozhraní URLUtils není použité pouze pro objekty URL, ale i pro objekt Location. Ve své implementaci URLUtils rozhraní obaluje vstupní řetězec s URL adresou -- input, který dále vnitřně parsuje za pomocí parseru URLParser, čímž vzniká objekt url třídy ParserURL (obrázek XY). Zpracovaná adresa ParserURL poskytuje náležitými gettery možnost získávání jednotlivých komponent URL adresy, které jsou přístupné právě přes URLUtils rozhraní. 

\begin{figure}[H]
  \begin{center}
    \scalebox{0.75}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-url-URL.pdf}
    }
    \caption{Diagram tříd znázorňující implementované rozhraní URL}
    \label{Figure.URLInterface}
  \end{center}
\end{figure}

Parser ParserURL vnitřně používá BasicURLParser, který zajišťuje náležité parsování předaného URL řetězce. Jelikož tvorba parseru nebyla cílem této práce, BasicURLParser nevytváří nový ParserURL objekt podle referenčního algoritmu tak, jak bylo uvedeno ve specifikaci. BasicURLParser pouze využívá již implementovaného parsovacího mechanismu v balíku java.net a třídy URL, jejíž objekt parsováním vznikne. Objekt třídy URL se obaluje do ParserURL rozhraní, což je zajištěno adaptující třídou WrappedURL.

Rozhraní URL vůči rozhraní URLUtils nepřidává žádnou další funkcionalitu, ale pouze definuje konstruktor pro tvorbu URL adresy, kterou objekt zapouzdřuje.

\section{Scriptovací architektura pro dokumenty}
\label{Chapter.Implementation.ScriptingArchitecture}

Do HTML dokumentů mohou být vkládány klientské skripty různých skriptovacích jazyků dle rozebrané problematiky v návrhu -- kapitole XY. Abychom umožnili snadnou implementaci klientských skriptovacích enginů pro různé skriptovací enginy, bylo nutné vytvořit základní abstraktní architekturu, která bude pro všechny skriptovací enginy společná. 

V této kapitole popíšeme implementaci abstraktního skriptovacího enginu a architekturu vytváření nativních objektů Javy tak, aby mohly být exportovány do klientských skriptů. Fundamentální implementace této architektury se nachází v balíku org.fit.cssbox.scriptbox.script. 

Architektura pro skriptací enginy vychází z kapitoly návrhu. Architektura byla v některých problematických částech mírně upravena tak, aby věrohodně kopírovala specifikaci HTML 5. Nejzásadnější změnou vůči návrhu je způsob spouštění skriptů. Skripty nejsou spouštěny pomocí jednotné třídy DocumentScriptEngine (kapitola XY), která eviduje všechny skriptovací enginy, asociuje je pro dané dokumenty a implementuje veškerou funkcionalitu pro jejich spouštění. Z důvodu prevence proti případné nekompatibilitě s danou specifikací, umožnění její snadnější a přesnější interpretace, bylo implementováno decentralizované spouštění skriptů. Odkaz na skriptovací engine není vlastněn globální instancí spravující třídy DocumentScriptEngine, ale dokumentem samotným ve speciálním objektu ScriptSettings (viz kapitola XY).

Implementované řešení provádění skriptů v dokumentu je popsáno v kapitole XY. Injekce objektů do hlavního scopu (kapitola XY) byla zcela implementována bez odlišností od návrhu, je rozebrána v kapitole XY. Tvorba JavaScript enginu podle JSR 223 (kapitola XY) byla též kompletně dodržena. Rhino engine byl v mnoha ohledech přizpůsoben a vylepšen tak, aby ho bylo možné využít pro klientské skripty. O implementovaném řešení JavaScript enginu pojednává kapitola XY.

\subsection{Rozhraní skriptů dokumentu}
\label{Chapter.Implementation.ScriptInterface}

Podle specifikace HTML5 bylo zapotřebí implementovat společné rozhraní pro skripty dokumentu. Rozhraní pro skripty je v implementaci reprezentováno abstraktní třídou Script. Každý skript využívá pro svoji tvorbu a běh určitého nastavení daného abstraktní třídou ScriptSettings. 

\begin{figure}[H]
  \begin{center}
    \scalebox{0.75}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-script-Script.pdf}
    }
    \caption{Diagram tříd znázorňující implementované rozhraní skriptu}
    \label{Figure.ScriptInterface}
  \end{center}
\end{figure}

Nastavení pro skripty deklaruje důležité aspekty prostředí, ve kterém by se měl skript vykonat. Třída ScriptSettings je abstraktní a v současné implementaci ji realizuje třída WindowScriptSettings. Instance nastavení je vytvářena vždy během konstrukce objektu Window, který je zároveň globálním objektem pro JavaScriptový engine. Třída WindowScriptEngine poskytuje referenci zejména na:

\begin{itemize}
  \item dokument, ve kterém se nachází spuštěný skript;
  \item globální objekt Window;
  \item bázovou URL adresu, která bude použita pro vytváření URL adres z adres relativních;
  \item událostní smyčku určenou pro skripty
  \item původ skriptu Origin, jeho kódování, atd. 
\end{itemize}

Jelikož nastavení pro skripty je unikátní pro každý objekt Window, který je přímo v 1:1 asociaci s objektem dokumentu, bylo nastavení využito pro tvorbu a uchovávání skriptovacích enginů dokumentu. Skriptovací enginy lze vytvářet zavoláním metody getExecutionEnviroment(). Jakmile je skriptovací engine již jednou vytvořen, je v konkrétním nastavení uchován a během příštího dotazu opět navrácen. Při vytváření neustále nových skriptovacích enginů by docházelo ke ztrátě uchovaného kontextu uvnitř enginů.

Abstraktní třída pro skripty Script potřebuje pro svoji konstrukci zdroj skriptu Source, jazyk skriptu, URL ze které byl případně skript získán, nastavení pro skripty ScriptSettingsType. V rámci tvorby instance skriptu se skript ihned provede zavoláním chráněné metody createScript(). Způsob spuštění skriptu je znázorněn na obrázku XY. Jakmile se ověří, zda je skriptování povoleno, dojde nejprve k získání skriptovacího enginu metodou obtainExecutionEnviroment(). Pak dojde k přípravě skriptu a získání vstupního bodu k vykonání CondeEntryPoint metodou obtainCodeEntryPoint(), který je vykonán metodou jumpToCodeEntryPoint(). Vykonávací metoda před spuštěním skriptu vkládá před spuštěním skriptu na zásobník ScriptSettingsStack aktuální nastavení skriptu, jež je po skončení vykonávání opět ze zásobníku odstraněno. Zásobník skriptů je potřebný v některých situacích, např. když chceme znát některé základní informace o nastavení skriptu, který spustil některou funkci jádra uživatelského agenta. Během navigování stránek metodou open() objektu Window se využívá zásobníku k určení zdrojového procházecího kontextu, který je totožný s responsivním procházecím kontextem skriptu.

\begin{figure}[H]
  \begin{center}
    \scalebox{0.75}{
      \includegraphics{fig/create-script.pdf}
    }
    \caption{Sekvenční diagram znázorňující tvorbu skriptu}
    \label{Figure.CreateScript}
  \end{center}
\end{figure}

Jedinými konkrétními třídami abstraktní třídy Script jsou třídy EvalWindowScript a InvokeWindowScript. Obě zmíněné třídy rozšiřují třídu WindowScript, jež předefinovává metodu prepareRunCallback(), do které přidává test, zda je dokument objektu Window plně aktivní. Pokud není dokument aktivní, vrací metoda nepravdu a skript není spuštěn.

Třída EvalWindowScript slouží k prostému vykonávání spustitelného kódu v nalezeném skriptovacím enginu. Zdrojem pro skripty EvalWindowScript je Reader. Během tvorby vstupního bodu CodeEntryPoint se vrací buď předaný zdroj skriptu, tzn. Reader, nebo zkompilovaný zdroj CompiledScript. Při vykonávání skriptu se volá buď eval() skriptovacího enginu nebo eval() zkompilovaného skriptu v závislosti na tom, jaký vstupní bod byl metodě executeCodeEntryPoint() předán.

Třída InvokeWindowScript plní funkci přímého volání funkcí v kontextu skriptovacího enginu. Zdrojem skriptu je rozhraní FunctionInvocation, které informuje o názvu funkce a argumentech, se kterými byla zavolána. Metoda vykonávání skriptu volá metodu invoke() vybraného skriptacího enginu s parametry, které byly získány pomocí rozhraní FunctionInvocation.

\subsection{Klientské skriptovací enginy}
\label{Chapter.Implementation.ScriptEngines}

Abstraktní skriptovací engine pro provádění skriptů popsaných v předchozí kapitole byl implementován podle návrhu tak, aby byl kompatibilní se specifikací JSR 223. Abstraktní engine dědí z třídy AbstractScriptEngine určené pro všechny skriptovací enginy standardního skriptovacího API. V implementaci je reprezentován třídou BrowserScriptEngine (obrázek \ref{Figure.BrowserScriptEngine}).

\begin{figure}[H]
  \begin{center}
    \scalebox{0.75}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-script-BrowserScriptEngine.pdf}
    }
    \caption{Diagram tříd znázorňující abstraktní skriptovací engine}
    \label{Figure.BrowserScriptEngine}
  \end{center}
\end{figure}

Všechny skriptovací enginy jsou vytvářeny pro některý konkrétní dokument, nad nímž je skriptovacím enginem uchováván skriptovací kontext. Pro jaký dokument byl skriptovací engine vytvořen, lze zjistit z nastavení pro skripty ScriptSettings, které je předáváno abstraktnímu skriptovacímu enginu během jeho konstrukce. V rámci třídy BrowserScriptEngine se s objektem ScriptSettings přímo nepracuje, ale v dalších specifičtějších třídách je dále využíván pro zjišťování globálního objektu. Globální objekt bývá obvykle konkrétními skriptovacími enginy implementován do enginového scopu daného skriptovacího enginu. Konkrétně třída WindowScriptEngine reprezentuje rozhraní pro zabudování globálního objektu Window.

Každý skriptovací engine obsahuje referenci na továrnu resolverů členů tříd ClassMembersResolverFactory. Resolver je použit k určení viditelných členů exportovaných objektů Javy pro implementaci globálního objektu a blíže je popsán v následující kapitole \ref{Chapter.Implementation.ExportConcepts}. 

Skriptovací enginy jsou vytvářeny továrnami BrowserScriptEngineFactory, které jsou evidovány a registrovány v singleton třídě BrowserScriptEngineManager. Manažerská třída všechny továrny skriptovacích enginů spravuje. Na dotázání je poskytuje vnějšímu okolí nebo případně ihned vytváří konkrétní skriptovací enginy některé továrny. Třídy BrowserScriptEngineFactory a BrowserScriptEngineManager rozšiřují třídy pro spravování továren obsahů v závislosti na MIME typu obsahu, které byly blíže popsány v kapitole \ref{Chapter.Implementation.ContentHandling}. Rozhodujícím faktorem pro vybrání odpovídající továrny skriptovacího enginu je MIME typ skriptu, na jehož základě je v manažeru továren skriptovacích enginů vyhledáváno.

\subsection{Koncepty exportu objektů Javy}
\label{Chapter.Implementation.ExportConcepts}

Z důvodu snadného přidávání nové implementace klientských skriptovacích enginů byly implementovány koncepty exportu nativních objektů Javy do kontextů skriptovacích enginů. Když chceme exportovat objekt, je výhodné vědět a určit, které prvky objektu mají být exportovány a jak by tyto prvky měly být reprezentovány v klientských skriptovacích enginech. Prvky zde myslíme členy třídy -- atributy, metody nebo konstruktory třídy. Za účelem specifikace exportovatelných členů tříd vznikla podpora, která přesně vyčleňuje jednotlivé členy tříd. Exportovatelné členy jsou vyhodnocovány ve třídách rozšiřující abstraktní třídu ClassMembers. Výchozí a jediná implementace pro určování členů tříd je hotova ve třídě DefaultClassMembers. Abstraktní třída ClassMembers vlastní odkaz na třídu, jejíž členy jsou vyhodnocovány, a odkaz na resolver, který jednotlivé členy rozpoznává. 

\begin{figure}[H]
  \begin{center}
    \scalebox{0.75}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-script-reflect-ClassMembers.pdf}
    }
    \caption{Diagram tříd znázorňující třídu reprezentující členy tříd}
    \label{Figure.ClassMembers}
  \end{center}
\end{figure}

Třídy resolverů slouží náležitou implementací metod začínajících prefixem is...() k určení, zda má být Java člen exportován nebo nikoliv. Pokud je člen exportovatelný, pak resolvery zprostředkovávají i extrakci názvů členů, pod kterými jsou členy viditelné v klientských skriptech. Pro účel extrakce jsou vyčleněny metody začínající prefixem extract…(). Závěrem resolvery vytváří metodami s prefixem construct…() obaly exportovatelných standardních Java členů -- členů Constructor, Field a Method. Poslední metodou, kterou poskytují resolvery, je metoda testu isObjectGetter() ověřující, zda je předaná metoda metodou pro indexované získávání objektů z objektu zkoumané třídy. Asociativní získávání objektů z objektu, neboli vytvoření asociativního pole z objektu, bylo implementováno z důvodu potřeby indexovaného získávání objektů WindowProxy vnořených procházecích kontextů z objektu Window podle jejich jména nebo indexu. Výchozí resolver DefaultClassMembersResolver exportuje všechny členy tříd Javy, přičemž jejich názvy extrahuje pomocí reflexe.

\begin{figure}[H]
  \begin{center}
    \scalebox{0.75}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-script-reflect-ClassMember.pdf}
    }
    \caption{Diagram tříd znázorňující třídy členů}
    \label{Figure.ClassMember}
  \end{center}
\end{figure}

Pro rozšíření funkčnosti standardních Java členů byly vytvořeny obalující třídy ClassFunction, ClassConstructor a ClassField tak, jak je znázorněno na obrázku \ref{Figure.ClassMember}. Obaly Java členů přidávají metody pomocné metody pro export a hlavně obsahují odkaz na pole možností options, které specifikuje způsob, jak by měl být člen implementován v klientském skriptu. V současné implementaci je možno uchovávat možnosti:

\begin{itemize}
  \item \textbf{\texttt{ENUMERABLE}} -- slouží pro určení, zda člen bude zúčastněn v seznamu všech výčtových členů objektu. V JavaScriptu umožňuje povolit nebo zabránit výpisu vlastnosti objektu, např. při průchodu for (var property in object). Tato možnost reflektuje ECMAScript atribut [[Enumerable]].
  \item \textbf{\texttt{PERNAMENT}} -- zda člen bude natrvalo svázán s objektem, v němž je definován, nebo může být přepsán během vykonávání skriptu za uživatelský objekt. Tato možnost zjednodušeně reflektuje Web IDL atributy [Unforgeable] a [Replaceable].
\end{itemize}

Z důvodu uchovávání a svázání členů tříd s objekty, které byly exportovány, byly implementovány třídy členů objektů: ObjectFunction, ObjectConstructor, ObjectField. Tyto třídy, jako třídy členů tříd, implementují rozhraní FunctionMember, ConstructorMember a FieldMember. Strom dědičnosti tříd členů objektů je obdobný jako u členů tříd. Objekty členů navíc od objektů členů uchovávají instanci exportovaného objektu, ale implementačně se od tříd členů tříd příliš neliší, proto zde nebudou blíže popisovány.

\subsection{Export objektů založený na anotacích}
\label{Chapter.Implementation.AnnotationExportConcepts}

Systém exportu objektů Javy s výchozí implementací resolveru členů třídy DefaultClassMembersResolver, popsaný v předchozí kapitole \ref{Chapter.Implementation.ExportConcepts}, umožňoval kompletní export objektů do klientských skriptů. Kompletní export není ovšem téměř nikdy žádoucí, jelikož do exportu jsou zahrnuty i např. metody třídy Object, ze které dědí každá třída Javy. Velmi často se prolíná vnitřní implementace členů objektu pro export a implementace členů, který by měly být ve skutečnosti exportovány. Nastala otázka, jak jednotlivé členy odlišit. Řešení se nabídlo v anotacích Javy, díky kterým bylo možné přesně určit exportovatelné členy a rozšířit exportování o další přídavné funkčnosti.

Pro export založený na anotacích členů tříd byl vytvořen nový resolver členů implementovaný třídou ScriptAnnotationClassMembersResolver. Resolver pro svoji funkci potřebuje referenci na skriptovací engine, který provádí vyhodnocování členů tříd. Bez znalosti skriptovacího enginu bychom nemohli rozhodnout, zda je daný člen exportovatelný pro konkrétní skriptovací engine. Pokud by bylo žádoucí exportování stejných členů do všech skriptovacích enginů a nemít možnost volby skriptovacího enginu, pro který je export validní, pak by reference na skriptovací engine nemusela existovat. Třída resolveru obsahuje ještě referenci na objekt Shutter, který zde neslouží k restrikci přístupu pro určité členy, třídy a balíčky, nýbrž k explicitnímu povolování členů, které nenesou žádnou anotaci. Pro implementaci funkčnosti třídy resolveru se využívá vnitřně pomocné třídy ScriptAnnotation, ve které se nachází pouze statické metody. Metody pomáhají určit, zda je daný člen exportovatelný na základě anotací pro daný skriptovací engine.

\begin{figure}[H]
  \begin{center}
    \scalebox{0.75}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-script-annotation-ScriptAnnotationClassMembersResolver.pdf}
    }
    \caption{Diagram tříd znázorňující resolver členů tříd založený na anotacích}
    \label{Figure.AnnotationClassMembersResolver}
  \end{center}
\end{figure}

V současné implementaci jsou podporovány skriptovací anotace pro členy třídy a třídy uvedené v  tabulce \ref{Table.SupportedEvents}.

\begin{table}[H]
  \begin{center} 
    \begin{tabular}{|p{4cm}|p{2cm}|p{8cm}|} \hline
    \theadStart{Anotace} & \thead{Působnost anotace} & \thead{Popis funkce anotace} \\ \hline
    \texttt{@InvisibleField} & Atribut & Zabránění exportu atributu \\ \hline
    \texttt{@InvisibleFunction} & Metoda & Zabránění exportu funkce\\ \hline
    \texttt{@ScriptClass} & Třída & Anotace pro exportovatelnou třídu -- nemusí být uvedena \\ \hline
    \texttt{@ScriptConstructor} & Konstruktor & Exportovatelný konstruktor objektu\\ \hline
    \texttt{@ScriptField} & Atribut & Exportovatelný atribut \\ \hline
    \texttt{@ScriptFunction} & Metoda & Exportovatelná funkce \\ \hline
    \texttt{@ScriptGetter} & Metoda & Exportovatelný atribut na základě getter metody \\ \hline
    \texttt{@ScriptSetter} & Metoda & Exportovatelný atribut na základě setter metody \\ \hline
    \end{tabular}
    \caption{Třídy podporovaných událostí}
    \label{Table.SupportedEvents}
  \end{center}
\end{table}

Každá skriptovací anotace obsahuje některé atributy, které omezují a ovlivňují export členů tříd. Všechny anotace mají společný jeden atribut engines s polem skriptovacích enginů, pro které je daná anotace validní. Pokud je pole engines prázdné, pak se předpokládá, že je člen s touto anotací viditelný pro všechny skriptovací enginy. 

Jedinou anotací, která není určena pro členy třídy, je anotace @ScriptClass, jež se uvádí nad typem třídy. Tato anotace umožňuje definovat rozsah automatického zahrnutí exportovatelných členů třídy, bez nutnosti definování odpovídající anotace u daného členu. Anotace přidává k popsanému atributu engines další atribut s polem options. Pokud zahrneme v poli s možnostmi anotace options, např. hodnotu ALL\_METHODS, tak budou exportovány všechny metody dané třídy, nad kterou je anotace uvedena. Další podporované možnosti anotace jsou: ALL\_FIELDS, ALL\_STATIC\_METHODS, ALL\_STATIC\_FIELDS, ALL\_CONSTRUCTORS. Jedinými anotacemi, které mohou ovlivnit automatické exporty po uvedení některé možnosti anotace @ScriptClass, jsou anotace @InvisibleField a @InvisibleFunction. Tyto anotace slouží k zabránění exportu členu třídy, který by byl normálně exportován. 

Když žádáme vytvoření některého atributu v klientském skriptu, máme hned tři možnosti jak toho docílit. Pro definici atributu můžeme použít anotaci @ScriptField, která přímo zpřístupní atribut, nad kterým je anotace uvedena. Dále lze použít anotací @ScriptGetter a @ScriptSetter, které vytvoří atribut z getter nebo setter metody, nad níž je anotace uvedena. Resolver pro anotace umožnuje pro všechny tři uvedené anotace automatické odvození názvu atributu. Název atributu lze předefinovat uvedením atributu anotace field, kde lze zvolit vlastní název pro atribut pro klientské skriptovací enginy. Pokud je jeden a tentýž atribut definován na více místech pomocí různých anotací, pak lze zvolit, zda by mělo mít přednost volání getteru nebo setter pro získávání atributu před přímým přístupem k atributu. Přednosti getterů a setterů se definují v možnostech anotací hodnotou FIELD\_GET\_OVERRIDE nebo FIELD\_SET\_OVERRIDE. Chceme-li zahrnout metody getterů a setterů do exportovatelných funkcí, pak lze v možnostech uvést hodnotu CALLABLE\_GETTER, CALLABLE\_SETTER.

U všech výše uvedených anotací, které sloužily pro export členu třídy, lze také zvolit, zda by tento člen měl mít nastavenou vlastnost ENUMERABLE popsanou v kapitole \ref{Chapter.Implementation.ExportConcepts}. Vlastnost PERNAMENT nelze v současné implementaci nastavovat. Proto všechny členy exportované pomocí skriptovacích anotací mají pevně nastavenou vlastností PERNAMENT.

\subsection{Další implementovaná funkčnost}
\label{Chapter.Implementation.OtherFunctionality}

V kapitole \ref{Chapter.Design.GlobalScopeInjections} jsme navrhli injekci do hlavního scopu. Koncept injekce byl zcela dodržen tak, jak byl navržen. Jednotlivé injektory ScriptContextInjector po zavolání metody registerScriptContextInject() registrují automaticky injekci, kterou v sobě nesou u všech továren skriptovacích enginů, ke kterým injektory náleží. Přejeme-li si zaregistrovat injektor u všech zaregistrovaných továren skriptovacích enginů, tak stačí během konstrukce injektoru předat místo pole názvů podporovaných skriptovacích enginů konstantu  ALL\_SCRIPT\_ENGINE\_FACTORIES. V současnosti jediným implementovaným injektorem, který je společný pro všechny skriptovací enginy uživatelského agenta, je URLInjector, který vkládá objekt pro konstrukci URL do hlavního scopu všech skriptovacích enginů. Pro JavaScriptový stroj byl dále implementován injektor vkládající speciální objekty, které reprezentují třídy klientského JavaScriptu, viz kapitola \ref{Chapter.Implementation.GlobalScopeImplementation}. Posledním implementovaným injektorem je injektor vkládající objekt konzole v rámci ukázkové aplikace. 

Během implementace se vyskytla potřeba převádět objekty na různá rozhraní, nejčastěji rozhraní neobsahující skriptovací anotace na objekty, které jsou již anotované a tak přístupné pro klientské skripty. Pro tento účel byl implementován jednoduchý registr adaptérů umožňující požadovanou funkčnost (obrázek \ref{Figure.AdapterRegistry}). Adaptéry jsou nyní používány třeba pro převod Xerces implementace událostí EventImpl, MouseEventImpl na třídy AdaptedEvent, AdaptedMouseEvent za pomocí adapterů EventAdapter a MouseEventAdapter. Jednotlivé skriptovací enginy by měly využívat tento registr adaptérů při zviditelňování nativních objektů Javy v klientských skriptech.

\begin{figure}[H]
  \begin{center}
    \scalebox{0.75}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-script-adapter-Adapter.pdf}
    }
    \caption{Diagram tříd znázorňující registr adaptérů}
    \label{Figure.AdapterRegistry}
  \end{center}
\end{figure}

\section{Klientský JavaScriptový engine}
\label{Chapter.Implementation.JavaScriptEngine}

V minulých kapitolách jsme popsali obecné společné rozhraní pro všechny skriptovací enginy. V této kapitole se zaměříme na konkrétní implementaci jediného skriptovacího enginu, který je nyní podporován -- skriptovacího enginu JavaScriptu.

JavaScriptový skriptovací engine byl implementován s využitím knihovny Rhino, která poskytuje jádro interpretu JavaScriptu. Implementovaný skriptovací engine je kompatibilní se specifikací JSR 223. Implementace JavaScriptového enginu podle JSR 223 v JDK nebylo využito z důvodu přizpůsobení skriptovacího enginu a kompletní kontroly nad zabudovaným prostředím Rhino. Standardní skriptovací API pro engine bylo implementováno zcela od základu. Jakým způsobem proběhlo propojením s Rhinem, je uvedeno v kapitole \ref{Chapter.Implementation.JavaScriptEngineInterface}.

V rámci konstrukce skriptovacího enginu dochází k tvorbě globálního scopu. Proces, který implementuje atributy a metody globálního objektu do globálního scopu, je popsán v kapitole \ref{Chapter.Implementation.GlobalScopeImplementation}. 

Knihovna Rhino exportuje nativní objekty Javy do prostředí JavaScriptu tak, že je zapouzdřuje do objektů NativeJavaObject, které implementují rozhraní Scriptable. Pro specifikaci členů objektů, které mají být implementovány, využívá Rhino třídy JavaMembers, která ovšem není veřejně přístupná. Z důvodu potřeby definice vlastních exportovatelných členů v rámci exportovaných objektů Javy, bylo nutné vytvořit vlastní zapouzdřující objekt. Jak zapouzdření proběhlo, je popsáno v kapitole \ref{Chapter.Implementation.NativeJavaWrappers}.

\subsection{Rozhraní JavaScriptového enginu}
\label{Chapter.Implementation.JavaScriptEngineInterface}

Skriptovací engine JavaScriptu je vytvářen továrnou WindowJavaScriptEngineFactory. V implementaci jej představuje třída WindowJavaScriptEngine (obrázek \ref{Figure.WindowJavaScriptEngine}). Pro jedno vlákno může být vytvořen pouze jeden skriptovací engine. Omezení je dáno z důvodu, že je skriptovací engine přímo spjat s kontextem Rhina, který se vytváří pro aktuální spuštěné vlákno. Skriptovací kontext Rhina slouží pro běh skriptů a je vytvářen před spuštěním nového skriptu. K vytváření kontextu se využívá továrny JavaScriptContextFactory, která je instanciována v rámci konstrukce skriptovacího enginu. Během konstrukce enginu také dochází k vytvoření globálního scopu TopLevel, jehož tvorba je blíže popsána v následující kapitole \ref{Chapter.Implementation.GlobalScopeImplementation}.

\begin{figure}[H]
  \begin{center}
    \scalebox{0.75}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-script-javascript-WindowJavaScriptEngine.pdf}
    }
    \caption{Diagram tříd znázorňující skriptovací engine JavaScriptu}
    \label{Figure.WindowJavaScriptEngine}
  \end{center}
\end{figure}

V rámci konstrukce továrny skriptovacího kontextu JavaScriptContextFactory se registrují jednotlivé podporované adaptéry pro skriptovací engine. Aktuálně jsou registrovány adaptéry: EventAdapter, UIEventAdapter, MouseEventAdapter a ErrorAdapter, jež převádí nativní objekty událostí na objekty viditelné ve skriptu. Když dochází k tvorbě kontextu, je pro kontext nastavena obalující továrna, která řetězí více metod obalování s využitím dekorátoru WrapFactoryDecorator blíže popsaného v kapitole \ref{Chapter.Implementation.NativeJavaWrappers}.

Skriptovací engine vlastní referenci na továrnu resolverů členů tříd, která se využívá pro export nativních objektů Javy. V aktuální implementaci se využívá továrny založené na anotacích ScriptAnnotationClassMembersResolverFactory. Skriptovací engine umožňuje volat funkce pomocí rozhraní Invocable nebo kompilovat skripty do objektů CompiledJavaScript s využitím rozhraní Compilable.

Abychom mohli implementovat data binding podle specifikace JSR 223, bylo nutno vytvořit speciální scope -- objekt ScripContextScriptable. Tento scope zpřístupňuje uložená data pomocí Bindings klientskému JavaScriptu a naopak z klientského JavaScriptu zprostředkovává rozhraní pro uložení dat skriptu.

\subsection{Implementace globálního scopu}
\label{Chapter.Implementation.GlobalScopeImplementation}

V rámci konstrukce skriptovacího enginu dochází k tvorbě globálního scopu. Globální scope je reprezentován v Rhinu třídou TopLevel. Jelikož klientský skript obsahuje globální scope, kde je implementován objekt Window, byla vytvořena rozšiřující třída ObjectTopLevel (obrázek \ref{Figure.ObjectTopLevel}), která daný objekt do globálního scopu vkládá. Globální objekt Window je získáván skriptovacím enginem z nastavení skriptu ScriptSettings a dále předáván v rámci konstrukce třídě ObjectTopLevel.

\begin{figure}[H]
  \begin{center}
    \scalebox{0.75}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-script-javascript-java-ObjectTopLevel.pdf}
    }
    \caption{Diagram tříd znázorňující objekt globálního scopu}
    \label{Figure.ObjectTopLevel}
  \end{center}
\end{figure}

Pro implementaci objektu do scopu využívá třída ObjectTopLevel instance implementátoru ObjectImplementor. Implementátor přijímá objekt, jenž má být implementován a členy třídy implementovaného objektu získané ze skriptovacího enginu. Implementátor tak ve skutečnosti zná všechny členy objektu ObjectMembers, které by měly být implementovány. Členy objektu jsou implementovány s využitím statických metod defineObjectField() a defineObjectFunction() třídy ObjectScriptable. Třída ObjectScriptable je nadstavbou nad ScriptableObject, která umožňuje v rámci své instance uchovat nativní objekt Javy, jenž sama zapouzdřuje. Při zavolání metody defineObjectField() vytváří objekt HostedJavaField, který následně do předaného scopu vkládá. Po zavolání metody defineObjectFunction() vytváří objekt HostedJavaMethod, který taktéž vkládá do předaného scopu. Nachází-li se v předaném scopu již jiný existující objekt HostedJavaMethod, pak je metoda ObjectFunction přidána do listu přetížených metod existujícího objektu HostedJavaMethod.

Z důvodu umožnění správné funkce operátoru instanceof, nebylo nutno do globálního scopu implementovat pouze globální objekt Window, ale také všechny objekty tříd. Přidání této podpory zajistil injektor ClassObjectInjector (obrázek \ref{Figure.ClassObjectsInjector}), který všechny třídy, jež by měly být viditelné ve skriptu, převádí na objekty ClassScriptable. Objekty ClassScriptable zapouzdřují objekt třídy a předefinovávají metodu hasInstance(), která se volá při kontrole, zda je předaná instance typu, jenž zapouzdřuje objekt ClassScriptable.

\begin{figure}[H]
  \begin{center}
    \scalebox{0.75}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-script-javascript-injectors-ClassObjectsInjector.pdf}
    }
    \caption{Diagram tříd znázorňující injektor globálního scopu}
    \label{Figure.ClassObjectsInjector}
  \end{center}
\end{figure}

Globální scope implementuje standardní objekty Javy a odstraňuje veškeré rozšiřující objekty Rhina, které by mohly narušit bezpečnost provádění skriptu, např. JavaImporter, Packages, importClass, importPackage, atd.

\subsection{Zapouzdření nativních objektů Javy}
\label{Chapter.Implementation.NativeJavaWrappers}

Implementováním globálního scopu jsme získali množinu atributů a metod, které mohou navracet nativní objekty Javy uživatelskému skriptu. Skriptovací engine ovšem nativním objektům „nerozumí“ a nedokáže s nimi pracovat, protože neimplementují rozhraní Scriptable. Knihovna Rhino řeší zapouzdřování objektů pomocí obalovací továrny WrapFactory, jejíž instance je uchovávána v objekt kontextu Rhina. Implementace obalovací továrny zapouzdřuje nativní objekty do objektu NativeJavaObject.

Jelikož nebylo možné ovlivnit exportovatelné členy nativních objektů, bylo nutné vytvořit novou obalující továrnu, která vytváří nový obal pro nativní objekty -- HostedJavaObject (obrázek \ref{Figure.HostedJavaObject}). Obal nativního objektu HostedJavaObject zapouzdřuje nativní objekt, k němuž lze přistoupit např. rozbalením díky rozhraní Wrapper. Na rozdíl od globálního kontextu, obal neimplementuje všechny exportovatelné členy do scopu, nýbrž vytváří pouze rozhraní pro přímý přístup do zapouzdřených nativních objektů. Obal obsahuje referenci na všechny exportovatelné členy ObjectMemers zapouzdřeného objektu a této reference využívá při potřebě získat nebo nastavit některou vlastnost zapouzdřeného objektu. Vlastnostmi zde máme na mysli i funkce zapouzdřeného objektu ObjectFunction, které předtím než je vrátíme, musí být obaleny do objektu HostedJavaMethod. Kromě zajištění rozhraní Scriptable rozšířením třídy ObjectScriptable, obal HostedJavaObject implementuje také rozhraní Function. Rozhraní Function je implementováno za účelem umožnění volání exportovatelných konstruktorů zapouzdřeného objektu. Při volání operátoru new dochází k volání metody construct(), které je obsaženo právě v rozhraní Function.

\begin{figure}[H]
  \begin{center}
    \scalebox{0.75}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-script-javascript-java-HostedJavaObject.pdf}
    }
    \caption{Diagram tříd znázorňující zapouzdřující objekt nativních objektů Javy}
    \label{Figure.HostedJavaObject}
  \end{center}
\end{figure}

Obalující objekt HostedJavaMethod rozšiřuje funkční objekt FunctionObject a umožňuje uchovávat všechny přetížené metody, jež tento objekt představuje. Z důvodu volání přetížených metod, byla předefinována metoda call(), která se provádí při volání funkce. Při invokaci funkce dochází nejprve k vyhledání metody v listu přetížených metod a pak k zavolání vybrané metody. Bylo implementováno jednoduché vyhledávání metodou getNearestObjectFunction(), která vyhledává funkce na základě počtu argumentů a jejich typů. Vyhledávání počítá i s možností volání metod s proměnnými argumenty.

Při nastavování nativních objektů JavaScriptu do některých rozhraní jádra uživatelského agenta, se naskytla potřeba některé tyto nativní objekty obalovat. V diagramu na obrázku \ref{Figure.HostedJavaObject} vidíme, že např. obal HostedJavaObject může vytvářet adaptující objekty FunctionEventHandlerAdapter a FunctionEventListenerAdapter. Tyto adaptéry jsou vytvářeny při požadavku na uložení nativní funkce JavaScriptu do některého z rozhraní EventHandler nebo EventListener. V aktuální implementaci není momentálně jednotné místo, které by se staralo o správu těchto adaptérů.

Výše popsaný obal nativních objektů Javy HostedJavaObject je vytvářen v rámci upravené obalující továrny DafaultWrapFactoryDecorator (obrázek \ref{Figure.WrapFactoryDecorator}). Vytvořená obalující továrna nově rozšiřuje třídu WrapFactoryDecorator, která umožňuje řetězení jednotlivých obalujících továren. 

\begin{figure}[H]
  \begin{center}
    \scalebox{0.75}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-script-javascript-wrap-WrapFactoryDecorator.pdf}
    }
    \caption{Diagram tříd znázorňující obalující továrny}
    \label{Figure.WrapFactoryDecorator}
  \end{center}
\end{figure}

Pro JavaScriptový engine byly implementovány celkem tři obalující továrny, které se provádí v následujícím pořadí:

\begin{enumerate}
  \item \textbf{\texttt{AdapterWrapFactoryDecorator}} -- obalující továrna převádějící nativní objekty, jež mají korespondující adaptér v registru adaptéru, na adaptované objekty. Továrna vždy volá následující zřetězenou továrnu;
  \item \textbf{\texttt{CollectionsWrapFactoryDecorator}} -- obalující továrna převádějící nativní kolekce Javy na objekt HostedJavaCollection, čímž zpřístupňuje jejich prvky ve skriptech. Pokud není nativní objekt kolekcí, pak dochází k zavolání poslední zřetězené továrny;
  \item \textbf{\texttt{DafaultWrapFactoryDecorator}} -- obalující továrny provádějící převod všech nativních objektů na objekty HostedJavaObject tak, jak bylo popsáno výše.
\end{enumerate}

\section{Uživatelské rozhraní pro prohlížení stránek}
\label{Chapter.Implementation.UserInterface}

V kapitole \ref{Chapter.Implementation.ContentHandling} jsme se zabývali zpracováním obsahu zdroje a jeho převodem na dokument. Dalším krokem v reálném prohlížeči by bylo zobrazení dokumentu uživateli a to již během jeho parsování. Jelikož není hotova podpora pro inkrementální a dynamické změny obsahu dokumentu, bylo implementováno zobrazování dokumentu až poté, co parser dokumentu dokončí svůj běh. Jednoduchou komponentu, která umožňuje prohlížení HTML dokumentů, implementuje třída ScriptBrowser. Komponenta vychází ze swingové komponenty BrowserPane implementované v projektu SwingBox.

\begin{figure}[H]
  \begin{center}
    \scalebox{0.75}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-ui-ScriptBrowserUserAgent.pdf}
    }
    \caption{Diagram tříd znázorňující komponentu k vykreslování dokumentů}
    \label{Figure.ScriptBrowserUserAgent}
  \end{center}
\end{figure}

Třída ScriptBrowser zapouzdřuje procházecí kontext okna, nad kterým registruje odběratele pro události generované navigačním kontrolerem a společnou historií sezení. Přijme-li odběratel událost, která znamená změnu dokumentu, pak tento odběratel volá metodu refresh(), jež způsobí vykreslení dokumentu. Během vykreslení dokumentu je získána reference na objekt EditorKit, nad nímž je zavoláno čtení dokumentu metodou read(). Jelikož dokument je již zpracován, tak metodě read() tento dokument předáme zapouzdřený do vstupního datového toku DocumentInputStream. Metoda read() vnitřně pro vykreslení dokumentu využívá instance ScriptAnalyzer, která byla s komponentou ScriptBrowser asociována během její konstrukce. V rámci metody analyze() třídy ScriptAnalyzer dochází k  získání zapouzdřeného dokumentu ze vstupního datového toku, analyzování objektu DOM třídou DOMAnalyzer a návrhu výsledného vzhledu dokumentu třídou BrowserCanvas.

Každá prohlížecí komponenta ScriptBrowser má asociovanou vlastní obslužnou rutinu pro to, co se má stát, když se klikne na URL odkaz. Obsluhu kliku na hyperlink implementuje třída ScriptBrowserHyperlinkHandler, která vnitřně volá navigační kontroler a statickou metodu followHyperlink(). Kromě obsluhy URL odkazů, komponent implementuje generování událostí myši pro příslušné uzly dokumentu, nad kterými událost nastala. Jelikož komponenta může obsahovat posuvníky, informuje procházecí jednotka ScriptBrowserBrowsingUnit pomocí rozhraní ScrollBar, zda jsou posuvníky aktivni či nikoliv.

\section{Ukázkové aplikace}
\label{Chapter.Implementation.DemoApplications}

Pro znázornění funkčnosti uživatelského agenta byly implementovány dvě ukázkové spustitelné aplikace, které demonstrují jeho základní funkce. Obě aplikace sloužily k otestování možnosti prohlížet HTML dokumenty. V implementaci se nachází v balíku org.fit.cssbox.scriptbox.ui.

Jednoduchá aplikace, která umožňuje pouze navigování stránek a procházení společné historie sezení, je podrobněji popsána v kapitole \ref{Chapter.Implementation.SimpleBrowser}. Další implementovanou aplikací, která přidává některé ladící komponenty klientského JavaScriptu, se zabývá kapitola \ref{Chapter.Implementation.JavaScriptTester}.  

\subsection{Jednoduchý prohlížeč}
\label{Chapter.Implementation.SimpleBrowser}

Pro vytvoření jednoduchého prohlížeče bylo zapotřebí definovat nového uživatelského agenta SimpleBrowserUserAgent (obrázek \ref{Figure.SimpleBrowserUiController}), který vytváří jednoduché procházecí jednotky SimpleBrowserBrowsingUnit obsahující uživatelské rozhraní. K implementaci jednoduchého uživatelského rozhraní bylo využito architektury MVP (model-view-presenter) s pasivním pohledem. Presenter v implementaci představuje třída SimpleBrowserUIPresenter, pohled třída SimpleBrowserUI a model uživatelský agent SimpleBrowserUserAgent.

\begin{figure}[H]
  \begin{center}
    \scalebox{0.75}{
      \includegraphics{fig/org-fit-cssbox-scriptbox-demo-browser-SimpleBrowserUiController.pdf}
    }
    \caption{Diagram tříd znázorňující rozšíření uživatelského agenta o uživatelské rozhraní}
    \label{Figure.SimpleBrowserUiController}
  \end{center}
\end{figure}

Během konstrukce procházecí jednotky dochází nejprve k tvorbě presenteru, který v rámci své tvorby vytváří pohled, se kterým je přímo spjat. Jakmile je pohled vytvořen, dochází presenterem k zaregistrování odběratelů událostí nad uživatelskými komponentami pohledu. Kromě odběratelů uživatelských komponent registruje presenter též odběratele u objektů uživatelského agenta, tzn. modelu. Konkrétně jsou zaregistrovány odběratelé nad navigačním kontrolerem hlavního procházecího kontextu a nad společnou historií sezení procházecí jednotky. Po zachycení událostí z navigačního kontroleru nebo společné historie sezení dochází presenterem k pasivní úpravě pohledu. Při dokončení stažení dokumentu je např. aktualizován název aplikace podle titulku stránky, po průchodu společnou historií sezení jsou aktualizovány tlačítka <- a ->.

Výsledný jednoduchý prohlížeč je zobrazen na obrázku \ref{Figure.SimpleBrowserScreenshot}. Prohlížeč umožňuje navigovat nové stránky pomocí navigačního řádku a procházet společnou historii sezení pomocí tlačítek <- a ->. 

\begin{figure}[H]
  \begin{center}
    \scalebox{0.75}{
      \includegraphics{fig/browser.png}
    }
    \caption{Uživatelské rozhraní jednoduchého prohlížeče}
    \label{Figure.SimpleBrowserScreenshot}
  \end{center}
\end{figure}

\subsection{Tester JavaScriptových skriptů}
\label{Chapter.Implementation.JavaScriptTester}

Během testování funkčnosti uživatelského agenta se naskytla potřeba pro ladění klientských skriptů JavaScriptu -- vznik tzv. testeru. Z tohoto důvodu bylo implementováno rozšíření jednoduchého prohlížeče uvedeného v předešlé kapitole \ref{Chapter.Implementation.SimpleBrowser}. Rozšíření přidalo ke komponentě pro prohlížení dokumentů další tři nové komponenty. Architektura pro tester byla zvolena také typu MVP. Presenter JavaScriptTesterUIPresenter  využívá implementované funkčnosti v presenteru SimpleBrowserUIPresenter. Vzhled pohledu JavaScriptTesterUI byl vytvořen zcela nový, ale implementuje rozhraní BrowserUI společné pro pohled jednoduchého prohlížeče.

První dvě komponenty, které byly navrženy a zcela implementovány umožňují procházet objekty, které jsou definované ve skriptu. Na obrázku \ref{Figure.ScriptObjectViewerAndWatchList} můžeme vidět komponentu ScriptObjectViewer a komponentu ScriptObjectsWatchList. 

\begin{figure}[H]
  \begin{center}
    \scalebox{0.75}{
      \includegraphics{fig/object-viewer-watch-list.png}
    }
    \caption{Komponenta \texttt{ScriptObjectViewer} (zleva) a komponenta \texttt{ScriptObjectsWatchList} (zprava)}
    \label{Figure.ScriptObjectViewerAndWatchList}
  \end{center}
\end{figure}

První komponenta ScriptObjectViewer umožňuje zobrazit všechny atributy objektu, který se jí předá. Společným objektem pro všechny klientské skripty je objekt Window, jehož bylo právě zvoleno pro výpis v aplikaci testeru. Jednotlivé položky ve výpisu nelze ovlivnit a jinak modifikovat. Komponenta je pouze informativní a ukazuje aktuální stav objektu Window.

Druhá komponenta ScriptObjectsWatchList přidává možnost volby objektů, které mají být ve výpisu objektů vypsány. Objekty lze do výpisu kdykoliv přidávat nebo je odstranit.  

Třetí komponenta (obrázek \ref{Figure.SourceCodeComponent}) slouží k procházení staženého zdrojového kódu dokumentu a k jeho případné modifikaci. Pro zvýraznění syntaxe byla použita získaná knihovna jsyntaxpane. V rámci komponenty lze dále vytvářet záložky, do kterých můžeme vkládat zdrojový kód, jenž je možno uložit nebo navigovat. Navigace vytvořeného zdrojového kódu probíhá tak, že se zdrojový kód uloží do složky dočasných souborů, ze které probíhá samotná navigace. 

\begin{figure}[H]
  \begin{center}
    \scalebox{0.75}{
      \includegraphics{fig/source-code.png}
    }
    \caption{Komponenta pro zobrazování zdrojového kódu dokumentu}
    \label{Figure.SourceCodeComponent}
  \end{center}
\end{figure}

Výsledná podoba aplikace je znázorněna na obrázku v příloze \ref{Figure.JavaScriptTester}.

\chapter{Závěr}
\label{Chapter.Final}

Cílem této práce bylo se seznámit s projektem CSSBox a zanalyzovat problematiku skriptování v jazyce JavaScript z jazyka Javy. Na základě získaných teoretických znalostí navrhnout architekturu a způsob integrace skriptovacího stroje do projektu CSSBox.

V rámci práce bylo nejprve analyzováno skriptování v HTML dokumentech a referenční způsob pro přidání skriptovací podpory do dokumentu. Byl představen projekt CSSBox, do kterého bude integrování rozšíření probíhat a komponenta SwingBox pro zobrazování HTML dokumentu.

V kapitole analýzy skriptovacích strojů byly demonstrovány existující řešení pro skriptování v jazyce JavaScript v Javovských aplikacích. Podrobně byla rozebrána technika tvorby skriptů s API knihovny Rhino. V kontrastu na tvoru skriptů s nestandardním API Rhina, byla ukázána i tvorba skriptu se standardním skriptovacím API Javy.

Návrh integrace rozšíření skriptování v JavaScriptu přímo reflektoval teoretickou analýzu z předešlých kapitol. Z důvodu asynchronního spouštění skriptů jsme museli navrhnout inkrementální načítání dokumentu. Abychom odstranili potřebu měnit kód skriptovacího stroje při přidávání nového rozšíření hlavního scopu, jsme navrhli injektování do skriptovacího stroje s využitím injektáže závislostí. Jelikož knihovna Rhino obsahovala pouze základní kontrolu přístupu do Javy z JavaScriptu, navrhli jsme také třídy pro rozmělnění bezpečnosti a lepší správu bezpečnostních politik. Závěrem návrhu jsme demonstrovali příklad „registrace“ samotného rozšíření do projektu SwingBox.
